import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@telegram-apps/sdk-react/dist/index.js
var import_react = __toESM(require_react());

// node_modules/@telegram-apps/sdk/dist/index.js
function Kr(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function ja(e, t2) {
  var n2;
  return (n2 = void 0) == null ? void 0 : n2.get(t2);
}
function qa(e) {
  var t2, n2;
  const r = typeof e;
  return r === "string" ? `"${e}"` : r === "number" || r === "bigint" || r === "boolean" ? `${e}` : r === "object" || r === "function" ? (e && ((n2 = (t2 = Object.getPrototypeOf(e)) == null ? void 0 : t2.constructor) == null ? void 0 : n2.name)) ?? "null" : r;
}
function ve(e, t2, n2, r, s) {
  const o = s && "input" in s ? s.input : n2.value, a = (s == null ? void 0 : s.expected) ?? e.expects ?? null, i = (s == null ? void 0 : s.received) ?? qa(o), u = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: a,
    received: i,
    message: `Invalid ${t2}: ${a ? `Expected ${a} but r` : "R"}eceived ${i}`,
    requirement: e.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, c = e.kind === "schema", l = (s == null ? void 0 : s.message) ?? e.message ?? ja(e.reference, u.lang) ?? (c ? (u.lang, void 0) : null) ?? r.message ?? (u.lang, void 0);
  l && (u.message = typeof l == "function" ? (
    // @ts-expect-error
    l(u)
  ) : l), c && (n2.typed = false), n2.issues ? n2.issues.push(u) : n2.issues = [u];
}
function K(e) {
  return {
    version: 1,
    vendor: "valibot",
    validate(t2) {
      return e["~run"]({ value: t2 }, Kr());
    }
  };
}
function Da(e, t2) {
  return Object.hasOwn(e, t2) && t2 !== "__proto__" && t2 !== "prototype" && t2 !== "constructor";
}
var Na = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), this.name = "ValiError", this.issues = e;
  }
};
function on(e, t2, n2) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t2, n2)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function et(e, t2) {
  return !e["~run"]({ value: t2 }, { abortEarly: true }).issues;
}
function Yr() {
  return {
    kind: "schema",
    type: "any",
    reference: Yr,
    expects: "any",
    async: false,
    get "~standard"() {
      return K(this);
    },
    "~run"(e) {
      return e.typed = true, e;
    }
  };
}
function qt(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: qt,
    expects: "boolean",
    async: false,
    message: e,
    get "~standard"() {
      return K(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "boolean" ? t2.typed = true : ve(this, "type", t2, n2), t2;
    }
  };
}
function an(e) {
  return {
    kind: "schema",
    type: "function",
    reference: an,
    expects: "Function",
    async: false,
    message: e,
    get "~standard"() {
      return K(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "function" ? t2.typed = true : ve(this, "type", t2, n2), t2;
    }
  };
}
function F(e, t2) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: F,
    expects: "Object",
    async: false,
    entries: e,
    message: t2,
    get "~standard"() {
      return K(this);
    },
    "~run"(n2, r) {
      var s;
      const o = n2.value;
      if (o && typeof o == "object") {
        n2.typed = true, n2.value = {};
        for (const a in this.entries) {
          const i = this.entries[a];
          if (a in o || (i.type === "exact_optional" || i.type === "optional" || i.type === "nullish") && // @ts-expect-error
          i.default !== void 0) {
            const u = a in o ? (
              // @ts-expect-error
              o[a]
            ) : on(i), c = i["~run"]({ value: u }, r);
            if (c.issues) {
              const l = {
                type: "object",
                origin: "value",
                input: o,
                key: a,
                value: u
              };
              for (const p of c.issues)
                p.path ? p.path.unshift(l) : p.path = [l], (s = n2.issues) == null || s.push(p);
              if (n2.issues || (n2.issues = c.issues), r.abortEarly) {
                n2.typed = false;
                break;
              }
            }
            c.typed || (n2.typed = false), n2.value[a] = c.value;
          } else if (i.type !== "exact_optional" && i.type !== "optional" && i.type !== "nullish" && (ve(this, "key", n2, r, {
            input: void 0,
            expected: `"${a}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: o,
                key: a,
                // @ts-expect-error
                value: o[a]
              }
            ]
          }), r.abortEarly))
            break;
        }
        if (!n2.issues || !r.abortEarly)
          for (const a in o)
            Da(o, a) && !(a in this.entries) && (n2.value[a] = o[a]);
      } else
        ve(this, "type", n2, r);
      return n2;
    }
  };
}
function xe(e, t2) {
  return {
    kind: "schema",
    type: "nullish",
    reference: xe,
    expects: `(${e.expects} | null | undefined)`,
    async: false,
    wrapped: e,
    default: t2,
    get "~standard"() {
      return K(this);
    },
    "~run"(n2, r) {
      return (n2.value === null || n2.value === void 0) && (this.default !== void 0 && (n2.value = on(this, n2, r)), n2.value === null || n2.value === void 0) ? (n2.typed = true, n2) : this.wrapped["~run"](n2, r);
    }
  };
}
function Dt(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Dt,
    expects: "number",
    async: false,
    message: e,
    get "~standard"() {
      return K(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "number" && !isNaN(t2.value) ? t2.typed = true : ve(this, "type", t2, n2), t2;
    }
  };
}
function Nt(e, t2) {
  return {
    kind: "schema",
    type: "optional",
    reference: Nt,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    default: t2,
    get "~standard"() {
      return K(this);
    },
    "~run"(n2, r) {
      return n2.value === void 0 && (this.default !== void 0 && (n2.value = on(this, n2, r)), n2.value === void 0) ? (n2.typed = true, n2) : this.wrapped["~run"](n2, r);
    }
  };
}
function re(e) {
  return {
    kind: "schema",
    type: "string",
    reference: re,
    expects: "string",
    async: false,
    message: e,
    get "~standard"() {
      return K(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "string" ? t2.typed = true : ve(this, "type", t2, n2), t2;
    }
  };
}
function Zr() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Zr,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return K(this);
    },
    "~run"(e) {
      return e.typed = true, e;
    }
  };
}
function Vt(e, t2, n2) {
  const r = e["~run"]({ value: t2 }, Kr(n2));
  if (r.issues)
    throw new Na(r.issues);
  return r.value;
}
function Xr(...e) {
  return {
    ...e[0],
    pipe: e,
    get "~standard"() {
      return K(this);
    },
    "~run"(t2, n2) {
      for (const r of e)
        if (r.kind !== "metadata") {
          if (t2.issues && (r.kind === "schema" || r.kind === "transformation")) {
            t2.typed = false;
            break;
          }
          (!t2.issues || !n2.abortEarly && !n2.abortPipeEarly) && (t2 = r["~run"](t2, n2));
        }
      return t2;
    }
  };
}
function es(e) {
  return et(
    F({ TelegramWebviewProxy: F({ postEvent: an() }) }),
    e
  );
}
function ts() {
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}
var Va = Object.defineProperty;
var La = (e, t2, n2) => t2 in e ? Va(e, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e[t2] = n2;
var Lt = (e, t2, n2) => La(e, typeof t2 != "symbol" ? t2 + "" : t2, n2);
function Ra(e) {
  return (t2) => t2 instanceof e;
}
function ns(e, t2) {
  t2 || (t2 = []);
  class n2 extends Error {
    constructor(...s) {
      const o = typeof t2 == "function" ? t2(...s) : typeof t2 == "string" ? [t2] : t2 || [];
      super(...o), this.name = e;
    }
  }
  return Object.defineProperty(n2, "name", { value: e }), [n2, Ra(n2)];
}
var [Ha, _f] = ns("CancelledError", "Promise was canceled");
var [Fa, bf] = ns(
  "TimeoutError",
  (e, t2) => [`Timeout reached: ${e}ms`, { cause: t2 }]
);
var rs = Symbol("Resolved");
function dr(e) {
  return Array.isArray(e) && e[0] === rs;
}
function Wa(e) {
  return [rs, e];
}
function fr(e, t2) {
  return e.reject = t2.reject, e.abort = t2.abort, e;
}
var un = class Rt extends Promise {
  constructor(t2, n2) {
    let r, s;
    super((o, a) => {
      let i, u;
      typeof t2 == "function" ? (i = t2, u = n2) : u = t2;
      const c = [], l = (d) => (...j) => {
        const ee = d(...j);
        return c.forEach(($t) => $t()), ee;
      }, p = new AbortController(), { signal: m } = p;
      s = (d) => {
        !m.aborted && p.abort(d);
      };
      const f = () => m.reason, A = (d) => {
        const j = () => {
          d(f());
        };
        m.addEventListener("abort", j, true);
        const ee = () => {
          m.removeEventListener("abort", j, true);
        };
        return c.push(ee), ee;
      }, be = l((d) => {
        o(d), s(Wa(d));
      });
      r = l((d) => {
        a(d), s(d);
      }), u || (u = {});
      const { abortSignal: M, rejectOnAbort: ne = true } = u;
      if (M)
        if (M.aborted) {
          const { reason: d } = M;
          if (ne)
            return r(d);
          s(d);
        } else {
          const d = () => {
            s(M.reason);
          };
          M.addEventListener("abort", d), c.push(() => {
            M.removeEventListener("abort", d);
          });
        }
      ne && A(a);
      const { timeout: E } = u;
      if (E) {
        const d = setTimeout(() => {
          s(new Fa(E));
        }, E);
        c.push(() => {
          clearTimeout(d);
        });
      }
      const $ = () => m.aborted, I = () => dr(f()), V = () => {
        const d = f();
        return dr(d) ? d[1] : void 0;
      };
      try {
        const d = i && i(be, r, {
          abortReason: f,
          abortSignal: m,
          isAborted: $,
          isResolved: I,
          onAborted: A,
          onResolved: (j) => A(() => {
            I() && j(V());
          }),
          resolved: V,
          throwIfAborted() {
            if ($())
              throw f();
          }
        });
        d instanceof Promise && d.catch(r);
      } catch (d) {
        r(d);
      }
    }), Lt(this, "abort"), Lt(this, "reject"), this.abort = s, this.reject = r;
  }
  /**
   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(t2, n2) {
    return new Rt(async (r, s, o) => {
      try {
        r(await t2(o));
      } catch (a) {
        s(a);
      }
    }, n2);
  }
  static resolve(t2) {
    return this.fn(() => t2);
  }
  /**
   * @see Promise.reject
   */
  static reject(t2) {
    return new Rt((n2, r) => {
      r(t2);
    });
  }
  /**
   * Aborts the promise with the cancel error.
   */
  cancel() {
    this.abort(new Ha());
  }
  /**
   * @see Promise.catch
   */
  catch(t2) {
    return this.then(void 0, t2);
  }
  /**
   * @see Promise.finally
   */
  finally(t2) {
    return fr(super.finally(t2), this);
  }
  /**
   * @see Promise.then
   */
  then(t2, n2) {
    return fr(super.then(t2, n2), this);
  }
};
function mr(e, t2) {
  return e.resolve = t2.resolve, e;
}
var yf = class Ht extends un {
  constructor(t2, n2) {
    let r, s;
    typeof t2 == "function" ? (r = t2, s = n2) : s = t2;
    let o;
    super((a, i, u) => {
      o = a, r && r(a, i, u);
    }, s), Lt(this, "resolve"), this.resolve = o;
  }
  /**
   * Creates a new ManualPromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(t2, n2) {
    return new Ht((r, s, o) => {
      try {
        Promise.resolve(t2(o)).then(r, s);
      } catch (a) {
        s(a);
      }
    }, n2);
  }
  static resolve(t2) {
    return this.fn(() => t2);
  }
  /**
   * @see Promise.reject
   */
  static reject(t2) {
    return new Ht((n2, r) => {
      r(t2);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(t2) {
    return this.then(void 0, t2);
  }
  /**
   * @see Promise.finally
   */
  finally(t2) {
    return mr(super.finally(t2), this);
  }
  /**
   * @see Promise.then
   */
  then(t2, n2) {
    return mr(super.then(t2, n2), this);
  }
};
function Ua(e) {
  return e.replace(/_[a-z]/g, (t2) => t2[1].toUpperCase());
}
function za(e) {
  return Object.entries(e).reduce((t2, [n2, r]) => (t2[Ua(n2)] = r, t2), {});
}
function Ft(e) {
  const t2 = za(e);
  for (const n2 in t2) {
    const r = t2[n2];
    r && typeof r == "object" && !(r instanceof Date) && (t2[n2] = Array.isArray(r) ? r.map(Ft) : Ft(r));
  }
  return t2;
}
function ss(e) {
  return `tapps/${e}`;
}
function os(e, t2) {
  sessionStorage.setItem(ss(e), JSON.stringify(t2));
}
function Ga(e) {
  const t2 = sessionStorage.getItem(ss(e));
  try {
    return t2 ? JSON.parse(t2) : void 0;
  } catch {
  }
}
function Qa(...e) {
  const t2 = e.flat(1);
  return [
    t2.push.bind(t2),
    () => {
      t2.forEach((n2) => {
        n2();
      });
    }
  ];
}
function Ja(e, t2) {
  t2 || (t2 = {});
  const {
    textColor: n2,
    bgColor: r,
    shouldLog: s
  } = t2, o = s === void 0 ? true : s, a = typeof o == "boolean" ? () => o : o;
  function i(u, c, ...l) {
    if (c || a()) {
      const p = "font-weight:bold;padding:0 5px;border-radius:5px";
      console[u](
        `%c${Intl.DateTimeFormat("en-GB", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          fractionalSecondDigits: 3,
          timeZone: "UTC"
        }).format(/* @__PURE__ */ new Date())}%c / %c${e}`,
        `${p};background-color: lightblue;color:black`,
        "",
        `${p};${n2 ? `color:${n2};` : ""}${r ? `background-color:${r}` : ""}`,
        ...l
      );
    }
  }
  return [i.bind(void 0, "log"), i.bind(void 0, "error")];
}
function as(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function Ka(e, t2) {
  var n2;
  return (n2 = void 0) == null ? void 0 : n2.get(t2);
}
function Ya(e) {
  var t2, n2;
  const r = typeof e;
  return r === "string" ? `"${e}"` : r === "number" || r === "bigint" || r === "boolean" ? `${e}` : r === "object" || r === "function" ? (e && ((n2 = (t2 = Object.getPrototypeOf(e)) == null ? void 0 : t2.constructor) == null ? void 0 : n2.name)) ?? "null" : r;
}
function q(e, t2, n2, r, s) {
  const o = s && "input" in s ? s.input : n2.value, a = (s == null ? void 0 : s.expected) ?? e.expects ?? null, i = (s == null ? void 0 : s.received) ?? Ya(o), u = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: a,
    received: i,
    message: `Invalid ${t2}: ${a ? `Expected ${a} but r` : "R"}eceived ${i}`,
    requirement: e.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, c = e.kind === "schema", l = (s == null ? void 0 : s.message) ?? e.message ?? Ka(e.reference, u.lang) ?? (c ? (u.lang, void 0) : null) ?? r.message ?? (u.lang, void 0);
  l && (u.message = typeof l == "function" ? (
    // @ts-expect-error
    l(u)
  ) : l), c && (n2.typed = false), n2.issues ? n2.issues.push(u) : n2.issues = [u];
}
function R(e) {
  return {
    version: 1,
    vendor: "valibot",
    validate(t2) {
      return e["~run"]({ value: t2 }, as());
    }
  };
}
function is(e, t2) {
  return Object.hasOwn(e, t2) && t2 !== "__proto__" && t2 !== "prototype" && t2 !== "constructor";
}
function Za(e, t2) {
  const n2 = [...new Set(e)];
  return n2.length > 1 ? `(${n2.join(` ${t2} `)})` : n2[0] ?? "never";
}
var Xa = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), this.name = "ValiError", this.issues = e;
  }
};
function us(e, t2) {
  return {
    kind: "validation",
    type: "check",
    reference: us,
    async: false,
    expects: null,
    requirement: e,
    message: t2,
    "~run"(n2, r) {
      return n2.typed && !this.requirement(n2.value) && q(this, "input", n2, r), n2;
    }
  };
}
function cs(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: cs,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    "~run"(t2, n2) {
      return t2.typed && !this.requirement(t2.value) && q(this, "integer", t2, n2), t2;
    }
  };
}
function oe(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: oe,
    async: false,
    operation: e,
    "~run"(t2) {
      return t2.value = this.operation(t2.value), t2;
    }
  };
}
function ls(e, t2, n2) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t2, n2)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function ei(e, t2) {
  return !e["~run"]({ value: t2 }, { abortEarly: true }).issues;
}
function Te(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: Te,
    expects: "boolean",
    async: false,
    message: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "boolean" ? t2.typed = true : q(this, "type", t2, n2), t2;
    }
  };
}
function ps(e) {
  return {
    kind: "schema",
    type: "date",
    reference: ps,
    expects: "Date",
    async: false,
    message: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      return t2.value instanceof Date ? isNaN(t2.value) ? q(this, "type", t2, n2, {
        received: '"Invalid Date"'
      }) : t2.typed = true : q(this, "type", t2, n2), t2;
    }
  };
}
function ds(e, t2) {
  return {
    kind: "schema",
    type: "instance",
    reference: ds,
    expects: e.name,
    async: false,
    class: e,
    message: t2,
    get "~standard"() {
      return R(this);
    },
    "~run"(n2, r) {
      return n2.value instanceof this.class ? n2.typed = true : q(this, "type", n2, r), n2;
    }
  };
}
function cn(e) {
  return {
    kind: "schema",
    type: "lazy",
    reference: cn,
    expects: "unknown",
    async: false,
    getter: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      return this.getter(t2.value)["~run"](t2, n2);
    }
  };
}
function $e(e, t2) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: $e,
    expects: "Object",
    async: false,
    entries: e,
    message: t2,
    get "~standard"() {
      return R(this);
    },
    "~run"(n2, r) {
      var s;
      const o = n2.value;
      if (o && typeof o == "object") {
        n2.typed = true, n2.value = {};
        for (const a in this.entries) {
          const i = this.entries[a];
          if (a in o || (i.type === "exact_optional" || i.type === "optional" || i.type === "nullish") && // @ts-expect-error
          i.default !== void 0) {
            const u = a in o ? (
              // @ts-expect-error
              o[a]
            ) : ls(i), c = i["~run"]({ value: u }, r);
            if (c.issues) {
              const l = {
                type: "object",
                origin: "value",
                input: o,
                key: a,
                value: u
              };
              for (const p of c.issues)
                p.path ? p.path.unshift(l) : p.path = [l], (s = n2.issues) == null || s.push(p);
              if (n2.issues || (n2.issues = c.issues), r.abortEarly) {
                n2.typed = false;
                break;
              }
            }
            c.typed || (n2.typed = false), n2.value[a] = c.value;
          } else if (i.type !== "exact_optional" && i.type !== "optional" && i.type !== "nullish" && (q(this, "key", n2, r, {
            input: void 0,
            expected: `"${a}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: o,
                key: a,
                // @ts-expect-error
                value: o[a]
              }
            ]
          }), r.abortEarly))
            break;
        }
        if (!n2.issues || !r.abortEarly)
          for (const a in o)
            is(o, a) && !(a in this.entries) && (n2.value[a] = o[a]);
      } else
        q(this, "type", n2, r);
      return n2;
    }
  };
}
function tt(e) {
  return {
    kind: "schema",
    type: "number",
    reference: tt,
    expects: "number",
    async: false,
    message: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "number" && !isNaN(t2.value) ? t2.typed = true : q(this, "type", t2, n2), t2;
    }
  };
}
function v(e, t2) {
  return {
    kind: "schema",
    type: "optional",
    reference: v,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    default: t2,
    get "~standard"() {
      return R(this);
    },
    "~run"(n2, r) {
      return n2.value === void 0 && (this.default !== void 0 && (n2.value = ls(this, n2, r)), n2.value === void 0) ? (n2.typed = true, n2) : this.wrapped["~run"](n2, r);
    }
  };
}
function fs(e, t2, n2) {
  return {
    kind: "schema",
    type: "record",
    reference: fs,
    expects: "Object",
    async: false,
    key: e,
    value: t2,
    message: n2,
    get "~standard"() {
      return R(this);
    },
    "~run"(r, s) {
      var o, a;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const u in i)
          if (is(i, u)) {
            const c = i[u], l = this.key["~run"]({ value: u }, s);
            if (l.issues) {
              const m = {
                type: "object",
                origin: "key",
                input: i,
                key: u,
                value: c
              };
              for (const f of l.issues)
                f.path = [m], (o = r.issues) == null || o.push(f);
              if (r.issues || (r.issues = l.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            const p = this.value["~run"](
              { value: c },
              s
            );
            if (p.issues) {
              const m = {
                type: "object",
                origin: "value",
                input: i,
                key: u,
                value: c
              };
              for (const f of p.issues)
                f.path ? f.path.unshift(m) : f.path = [m], (a = r.issues) == null || a.push(f);
              if (r.issues || (r.issues = p.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            (!l.typed || !p.typed) && (r.typed = false), l.typed && (r.value[l.value] = p.value);
          }
      } else
        q(this, "type", r, s);
      return r;
    }
  };
}
function y(e) {
  return {
    kind: "schema",
    type: "string",
    reference: y,
    expects: "string",
    async: false,
    message: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "string" ? t2.typed = true : q(this, "type", t2, n2), t2;
    }
  };
}
function hr(e) {
  let t2;
  if (e)
    for (const n2 of e)
      t2 ? t2.push(...n2.issues) : t2 = n2.issues;
  return t2;
}
function ln(e, t2) {
  return {
    kind: "schema",
    type: "union",
    reference: ln,
    expects: Za(
      e.map((n2) => n2.expects),
      "|"
    ),
    async: false,
    options: e,
    message: t2,
    get "~standard"() {
      return R(this);
    },
    "~run"(n2, r) {
      let s, o, a;
      for (const i of this.options) {
        const u = i["~run"]({ value: n2.value }, r);
        if (u.typed)
          if (u.issues)
            o ? o.push(u) : o = [u];
          else {
            s = u;
            break;
          }
        else
          a ? a.push(u) : a = [u];
      }
      if (s)
        return s;
      if (o) {
        if (o.length === 1)
          return o[0];
        q(this, "type", n2, r, {
          issues: hr(o)
        }), n2.typed = true;
      } else {
        if ((a == null ? void 0 : a.length) === 1)
          return a[0];
        q(this, "type", n2, r, {
          issues: hr(a)
        });
      }
      return n2;
    }
  };
}
function ms() {
  return {
    kind: "schema",
    type: "unknown",
    reference: ms,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return R(this);
    },
    "~run"(e) {
      return e.typed = true, e;
    }
  };
}
function hs(e, t2, n2) {
  const r = e["~run"]({ value: t2 }, as(n2));
  if (r.issues)
    throw new Xa(r.issues);
  return r.value;
}
function ae(...e) {
  return {
    ...e[0],
    pipe: e,
    get "~standard"() {
      return R(this);
    },
    "~run"(t2, n2) {
      for (const r of e)
        if (r.kind !== "metadata") {
          if (t2.issues && (r.kind === "schema" || r.kind === "transformation")) {
            t2.typed = false;
            break;
          }
          (!t2.issues || !n2.abortEarly && !n2.abortPipeEarly) && (t2 = r["~run"](t2, n2));
        }
      return t2;
    }
  };
}
function ti(e) {
  return e.replace(/_[a-z]/g, (t2) => t2[1].toUpperCase());
}
function ni(e) {
  return Object.entries(e).reduce((t2, [n2, r]) => (t2[ti(n2)] = r, t2), {});
}
function Wt(e) {
  const t2 = ni(e);
  for (const n2 in t2) {
    const r = t2[n2];
    r && typeof r == "object" && !(r instanceof Date) && (t2[n2] = Array.isArray(r) ? r.map(Wt) : Wt(r));
  }
  return t2;
}
function pn(e) {
  return oe((t2) => e ? Wt(t2) : t2);
}
function _s(e) {
  return (t2) => ae(
    e,
    pn(t2)
  );
}
function ri(e) {
  return (t2, n2) => hs(
    ae(e, pn(n2)),
    t2
  );
}
function dn() {
  return oe(JSON.parse);
}
function fn(e) {
  const t2 = _s(e);
  return (n2) => ae(
    y(),
    dn(),
    t2(n2)
  );
}
function si(e) {
  return oe((t2) => {
    const n2 = {};
    return new URLSearchParams(t2).forEach((r, s) => {
      const o = n2[s];
      Array.isArray(o) ? o.push(r) : o === void 0 ? n2[s] = r : n2[s] = [o, r];
    }), hs(e, n2);
  });
}
function bs(e) {
  return (t2) => ae(
    ln([y(), ds(URLSearchParams)]),
    si(e),
    pn(t2)
  );
}
var _r = v(cn(() => ci()));
var oi = $e({
  id: tt(),
  photo_url: v(y()),
  type: y(),
  title: y(),
  username: v(y())
});
var ai = $e({
  added_to_attachment_menu: v(Te()),
  allows_write_to_pm: v(Te()),
  first_name: y(),
  id: tt(),
  is_bot: v(Te()),
  is_premium: v(Te()),
  last_name: v(y()),
  language_code: v(y()),
  photo_url: v(y()),
  username: v(y())
});
var ii = $e({
  auth_date: ae(
    y(),
    oe((e) => new Date(Number(e) * 1e3)),
    ps()
  ),
  can_send_after: v(ae(y(), oe(Number), cs())),
  chat: v(cn(() => ui())),
  chat_type: v(y()),
  chat_instance: v(y()),
  hash: y(),
  query_id: v(y()),
  receiver: _r,
  start_param: v(y()),
  signature: y(),
  user: _r
});
var ui = fn(oi);
var ci = fn(ai);
var li = bs(ii);
function pi(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
var ys = _s(
  fs(
    y(),
    ae(
      ln([y(), tt()]),
      oe((e) => typeof e == "number" ? `#${(e & 16777215).toString(16).padStart(6, "0")}` : e),
      us(pi)
    )
  )
);
var St = v(
  ae(y(), oe((e) => e === "1"))
);
var br = fn(ys());
var di = $e({
  tgWebAppBotInline: St,
  tgWebAppData: v(li()),
  tgWebAppDefaultColors: v(br()),
  tgWebAppFullscreen: St,
  tgWebAppPlatform: y(),
  tgWebAppShowSettings: St,
  tgWebAppStartParam: v(y()),
  tgWebAppThemeParams: br(),
  tgWebAppVersion: y()
});
var gs = bs(di);
var fi = ri(gs());
var vs = $e({
  eventType: y(),
  eventData: v(ms())
});
function ws(e, t2) {
  return t2 || (t2 = (n2, r) => JSON.stringify(r)), new URLSearchParams(
    Object.entries(e).reduce((n2, [r, s]) => (Array.isArray(s) ? n2.push(...s.map((o) => [r, String(o)])) : s != null && n2.push([
      r,
      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == "string" || typeof s == "number" ? String(s) : typeof s == "boolean" ? s ? "1" : "0" : t2(r, s)
    ]), n2), [])
  ).toString();
}
function mi(e) {
  return ws(e);
}
function hi(e) {
  return ws(e, (t2, n2) => t2 === "tgWebAppData" ? mi(n2) : JSON.stringify(n2));
}
function Es(e) {
  try {
    return ei(gs(), e);
  } catch {
    return false;
  }
}
function _i(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t2, n2) {
    var r = e.get(t2);
    r ? r.push(n2) : e.set(t2, [n2]);
  }, off: function(t2, n2) {
    var r = e.get(t2);
    r && (n2 ? r.splice(r.indexOf(n2) >>> 0, 1) : e.set(t2, []));
  }, emit: function(t2, n2) {
    var r = e.get(t2);
    r && r.slice().map(function(s) {
      s(n2);
    }), (r = e.get("*")) && r.slice().map(function(s) {
      s(t2, n2);
    });
  } };
}
function bi(e, t2) {
  const n2 = _i(), r = /* @__PURE__ */ new Map(), s = (o, a, i) => {
    i || (i = false);
    const u = r.get(o) || /* @__PURE__ */ new Map();
    r.set(o, u);
    const c = u.get(a) || [];
    u.set(a, c);
    const l = c.findIndex((p) => p[1] === i);
    l >= 0 && (n2.off(o, c[l][0]), c.splice(l, 1), !c.length && u.delete(a), u.size || (r.delete(o), !r.size && t2()));
  };
  return [
    function(o, a, i) {
      !r.size && e();
      function u() {
        s(o, a, i);
      }
      function c(...m) {
        i && u(), o === "*" ? a(m) : a(...m);
      }
      n2.on(o, c);
      const l = r.get(o) || /* @__PURE__ */ new Map();
      r.set(o, l);
      const p = l.get(a) || [];
      return l.set(a, p), p.push([c, i || false]), u;
    },
    s,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    n2.emit,
    function() {
      const o = n2.all.size;
      n2.all.clear(), r.clear(), o && t2();
    }
  ];
}
function yr(e, t2) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t2 }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
var We = false;
var [mn, yi] = Ja("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog() {
    return We;
  }
});
var gr = (e) => {
  mn(false, "Event received:", e);
};
function gi(e) {
  e !== We && (We = e, We ? k("*", gr) : B("*", gr));
}
var vi = {
  clipboard_text_received: F({
    req_id: re(),
    data: xe(re())
  }),
  custom_method_invoked: F({
    req_id: re(),
    result: Nt(Zr()),
    error: Nt(re())
  }),
  popup_closed: xe(
    F({ button_id: xe(re(), () => {
    }) }),
    {}
  ),
  viewport_changed: F({
    height: Dt(),
    width: xe(Dt(), () => window.innerWidth),
    is_state_stable: qt(),
    is_expanded: qt()
  }),
  theme_changed: F({
    theme_params: ys()
  })
};
function vr(e) {
  if (e.source !== window.parent)
    return;
  let t2;
  try {
    t2 = Vt(Xr(re(), dn(), vs), e.data);
  } catch {
    return;
  }
  const { eventType: n2, eventData: r } = t2, s = vi[n2];
  try {
    const o = s ? Vt(s, r) : r;
    wi(n2, o);
  } catch (o) {
    yi(
      true,
      [
        `An error occurred processing the "${n2}" event from the Telegram application.`,
        "Please, file an issue here:",
        "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
      ].join(`
`),
      t2,
      o
    );
  }
}
var [
  k,
  B,
  wi,
  gf
] = bi(
  () => {
    const e = window, t2 = { receiveEvent: yr };
    e.TelegramGameProxy_receiveEvent = yr, e.TelegramGameProxy = t2, e.Telegram = { WebView: t2 }, window.addEventListener("message", vr);
  },
  () => {
    ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
      delete window[e];
    }), window.removeEventListener("message", vr);
  }
);
function Ei(e) {
  return (t2) => t2 instanceof e;
}
function Se(e, t2) {
  t2 || (t2 = []);
  class n2 extends Error {
    constructor(...s) {
      const o = typeof t2 == "function" ? t2(...s) : typeof t2 == "string" ? [t2] : t2 || [];
      super(...o), this.name = e;
    }
  }
  return Object.defineProperty(n2, "name", { value: e }), [n2, Ei(n2)];
}
var [
  $i,
  vf
] = Se(
  "MethodUnsupportedError",
  (e, t2) => [
    `Method "${e}" is unsupported in Mini Apps version ${t2}`
  ]
);
var [
  Si,
  wf
] = Se(
  "MethodParameterUnsupportedError",
  (e, t2, n2) => [
    `Parameter "${t2}" of "${e}" method is unsupported in Mini Apps version ${n2}`
  ]
);
var Ci = [
  "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
  "ðŸ“– Refer to docs for more information:",
  "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment"
].join(`
`);
var [
  ki,
  Ef
] = Se("LaunchParamsRetrieveError", Ci);
var [
  Ai,
  $f
] = Se("InvalidLaunchParamsError", (e) => [
  `Invalid value for launch params: ${e}`
]);
var [Mi, Sf] = Se("UnknownEnvError");
var [
  Pi,
  Cf
] = Se(
  "InvokeCustomMethodError",
  (e) => [`Server returned error: ${e}`]
);
function xi(e, t2) {
  t2();
}
function Ti(e, t2) {
  t2 || (t2 = {});
  const n2 = t2.equals || Object.is;
  let r = [], s = e;
  const o = (c) => {
    if (!n2(s, c)) {
      const l = s;
      s = c, xi(u, () => {
        [...r].forEach(([p, m]) => {
          p(c, l), m && i(p, true);
        });
      });
    }
  };
  function a(c) {
    const l = typeof c != "object" ? { once: c } : c;
    return {
      once: l.once || false,
      signal: l.signal || false
    };
  }
  const i = (c, l) => {
    const p = a(l), m = r.findIndex(([f, A]) => f === c && A.once === p.once && A.signal === p.signal);
    m >= 0 && r.splice(m, 1);
  }, u = Object.assign(
    function() {
      return Bi(u), s;
    },
    {
      destroy() {
        r = [];
      },
      set: o,
      reset() {
        o(e);
      },
      sub(c, l) {
        return r.push([c, a(l)]), () => i(c, l);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((c) => c[1].signal);
      }
    }
  );
  return u;
}
var Ct = [];
function Bi(e) {
  Ct.length && Ct[Ct.length - 1].add(e);
}
var Oi = Ti("https://web.telegram.org");
function hn(e, t2) {
  mn(false, "Posting event:", t2 ? { eventType: e, eventData: t2 } : { eventType: e });
  const n2 = window, r = JSON.stringify({ eventType: e, eventData: t2 });
  if (ts())
    return n2.parent.postMessage(r, Oi());
  if (es(n2)) {
    n2.TelegramWebviewProxy.postEvent(e, JSON.stringify(t2));
    return;
  }
  if (et(F({ external: F({ notify: an() }) }), n2)) {
    n2.external.notify(r);
    return;
  }
  throw new Mi();
}
function _n(e, t2, n2) {
  n2 || (n2 = {});
  const { capture: r } = n2, [s, o] = Qa();
  return new un((a) => {
    (Array.isArray(t2) ? t2 : [t2]).forEach((i) => {
      s(
        k(i, (u) => {
          (!r || (Array.isArray(t2) ? r({
            event: i,
            payload: u
          }) : r(u))) && a(u);
        })
      );
    }), (n2.postEvent || hn)(e, n2.params);
  }, n2).finally(o);
}
var wr = "launchParams";
function Er(e) {
  return e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&");
}
function $s() {
  for (const e of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    () => Er(window.location.href),
    // Then, try using the lower level API - window.performance.
    () => {
      const t2 = performance.getEntriesByType("navigation")[0];
      return t2 && Er(t2.name);
    },
    () => Ga(wr)
  ]) {
    const t2 = e();
    if (t2 && Es(t2))
      return os(wr, t2), t2;
  }
  throw new ki();
}
function bn(e) {
  const t2 = fi($s());
  return e ? Ft(t2) : t2;
}
function $r(e, t2) {
  if (!e)
    try {
      return bn(), true;
    } catch {
      return false;
    }
  return un.fn(async (n2) => {
    if (es(window))
      return true;
    try {
      return await _n("web_app_request_theme", "theme_changed", n2), true;
    } catch {
      return false;
    }
  }, t2 || { timeout: 100 });
}
function kf({ launchParams: e, onEvent: t2 } = {}) {
  if (e) {
    const s = typeof e == "string" || e instanceof URLSearchParams ? e.toString() : (
      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid
      // value. We are doing it because we are working with tgWebAppData presented as a
      // string, not an object as serializeLaunchParamsQuery requires.
      hi({ ...e, tgWebAppData: void 0 }) + (e.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(e.tgWebAppData.toString())}` : "")
    );
    if (!Es(s))
      throw new Ai(s);
    os("launchParams", s);
  }
  if (ts()) {
    const s = Xr(
      re(),
      dn(),
      vs
    ), o = window.parent.postMessage.bind(window.parent);
    window.parent.postMessage = (...a) => {
      const [i] = a, u = () => {
        o(...a);
      };
      if (et(s, i) && t2) {
        const c = Vt(s, i);
        t2([c.eventType, c.eventData], u);
      } else
        u();
    };
    return;
  }
  const n2 = window.TelegramWebviewProxy || {}, { postEvent: r } = n2;
  window.TelegramWebviewProxy = {
    ...n2,
    postEvent(s, o) {
      const a = () => {
        r && r(s, o);
      };
      t2 ? t2([s, o ? JSON.parse(o) : void 0], a) : a();
    }
  }, mn(false, "Environment was mocked by the mockTelegramEnv function");
}
function Ii() {
  return new URLSearchParams($s()).get("tgWebAppData") || void 0;
}
function Ss(e) {
  return ({ req_id: t2 }) => t2 === e;
}
function Sr(e) {
  return e.split(".").map(Number);
}
function ji(e, t2) {
  const n2 = Sr(e), r = Sr(t2), s = Math.max(n2.length, r.length);
  for (let o = 0; o < s; o += 1) {
    const a = n2[o] || 0, i = r[o] || 0;
    if (a !== i)
      return a > i ? 1 : -1;
  }
  return 0;
}
function P(e, t2) {
  return ji(e, t2) <= 0;
}
function de(e, t2, n2) {
  if (typeof n2 == "string") {
    if (e === "web_app_open_link") {
      if (t2 === "try_instant_view")
        return P("6.4", n2);
      if (t2 === "try_browser")
        return P("7.6", n2);
    }
    if (e === "web_app_set_header_color" && t2 === "color")
      return P("6.9", n2);
    if (e === "web_app_close" && t2 === "return_back")
      return P("7.6", n2);
    if (e === "web_app_setup_main_button" && t2 === "has_shine_effect")
      return P("7.10", n2);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return P("6.1", t2);
    case "web_app_open_popup":
      return P("6.2", t2);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return P("6.4", t2);
    case "web_app_switch_inline_query":
      return P("6.7", t2);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return P("6.9", t2);
    case "web_app_setup_settings_button":
      return P("6.10", t2);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return P("7.2", t2);
    case "web_app_setup_swipe_behavior":
      return P("7.7", t2);
    case "web_app_share_to_story":
      return P("7.8", t2);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return P("7.10", t2);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_add_to_home_screen":
    case "web_app_check_home_screen":
    case "web_app_request_emoji_status_access":
    case "web_app_check_location":
    case "web_app_open_location_settings":
    case "web_app_request_file_download":
    case "web_app_request_location":
    case "web_app_send_prepared_message":
    case "web_app_start_accelerometer":
    case "web_app_start_device_orientation":
    case "web_app_start_gyroscope":
    case "web_app_stop_accelerometer":
    case "web_app_stop_device_orientation":
    case "web_app_stop_gyroscope":
    case "web_app_toggle_orientation_lock":
      return P("8.0", t2);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function qi(e, t2) {
  t2 || (t2 = "strict");
  const n2 = typeof t2 == "function" ? t2 : (r) => {
    const { method: s, version: o } = r, a = "param" in r ? new Si(s, r.param, o) : new $i(s, o);
    if (t2 === "strict")
      throw a;
    return console.warn(a.message);
  };
  return (r, s) => de(r, e) ? r === "web_app_set_header_color" && et(F({ color: Yr() }), s) && !de(r, "color", e) ? n2({ version: e, method: r, param: "color" }) : hn(r, s) : n2({ version: e, method: r });
}
function Di(e, t2, n2, r) {
  return _n("web_app_invoke_custom_method", "custom_method_invoked", {
    ...r || {},
    params: { method: e, params: t2, req_id: n2 },
    capture: Ss(n2)
  }).then(({ result: s, error: o }) => {
    if (o)
      throw new Pi(o);
    return s;
  });
}
function Cs(e) {
  return e.replace(/[A-Z]/g, (t2) => `-${t2.toLowerCase()}`);
}
function Ni(e) {
  return e.replace(/_([a-z])/g, (t2, n2) => `-${n2.toLowerCase()}`);
}
function ks(e) {
  return `tapps/${e}`;
}
function W(e, t2) {
  sessionStorage.setItem(ks(e), JSON.stringify(t2));
}
function U(e) {
  const t2 = sessionStorage.getItem(ks(e));
  try {
    return t2 ? JSON.parse(t2) : void 0;
  } catch {
  }
}
function yn(...e) {
  const t2 = e.flat(1);
  return [
    t2.push.bind(t2),
    () => {
      t2.forEach((n2) => {
        n2();
      });
    }
  ];
}
function Vi(e, t2) {
  t2 || (t2 = {});
  const {
    textColor: n2,
    bgColor: r,
    shouldLog: s
  } = t2, o = s === void 0 ? true : s, a = typeof o == "boolean" ? () => o : o;
  function i(u, c, ...l) {
    if (c || a()) {
      const p = "font-weight:bold;padding:0 5px;border-radius:5px";
      console[u](
        `%c${Intl.DateTimeFormat("en-GB", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          fractionalSecondDigits: 3,
          timeZone: "UTC"
        }).format(/* @__PURE__ */ new Date())}%c / %c${e}`,
        `${p};background-color: lightblue;color:black`,
        "",
        `${p};${n2 ? `color:${n2};` : ""}${r ? `background-color:${r}` : ""}`,
        ...l
      );
    }
  }
  return [i.bind(void 0, "log"), i.bind(void 0, "error")];
}
function Li() {
  return performance.getEntriesByType("navigation")[0];
}
function z() {
  const e = Li();
  return !!e && e.type === "reload";
}
var ye;
function Ri(e, t2) {
  ye && ye.set(e, t2) || t2();
}
function Ut(e) {
  if (ye)
    return e();
  ye = /* @__PURE__ */ new Map();
  try {
    e();
  } finally {
    ye.forEach((t2) => t2()), ye = void 0;
  }
}
function As(e, t2) {
  t2 || (t2 = {});
  const n2 = t2.equals || Object.is;
  let r = [], s = e;
  const o = (c) => {
    if (!n2(s, c)) {
      const l = s;
      s = c, Ri(u, () => {
        [...r].forEach(([p, m]) => {
          p(c, l), m && i(p, true);
        });
      });
    }
  };
  function a(c) {
    const l = typeof c != "object" ? { once: c } : c;
    return {
      once: l.once || false,
      signal: l.signal || false
    };
  }
  const i = (c, l) => {
    const p = a(l), m = r.findIndex(([f, A]) => f === c && A.once === p.once && A.signal === p.signal);
    m >= 0 && r.splice(m, 1);
  }, u = Object.assign(
    function() {
      return Hi(u), s;
    },
    {
      destroy() {
        r = [];
      },
      set: o,
      reset() {
        o(e);
      },
      sub(c, l) {
        return r.push([c, a(l)]), () => i(c, l);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((c) => c[1].signal);
      }
    }
  );
  return u;
}
var Oe = [];
function Hi(e) {
  Oe.length && Oe[Oe.length - 1].add(e);
}
function Fi(e, t2) {
  let n2 = /* @__PURE__ */ new Set(), r;
  function s() {
    return r || (r = As(a(), t2));
  }
  function o() {
    s().set(a());
  }
  function a() {
    n2.forEach((c) => {
      c.unsub(o, { signal: true });
    });
    const i = /* @__PURE__ */ new Set();
    let u;
    Oe.push(i);
    try {
      u = e();
    } finally {
      Oe.pop();
    }
    return i.forEach((c) => {
      c.sub(o, { signal: true });
    }), n2 = i, u;
  }
  return Object.assign(function() {
    return s()();
  }, {
    destroy() {
      s().destroy();
    },
    sub(...i) {
      return s().sub(...i);
    },
    unsub(...i) {
      s().unsub(...i);
    },
    unsubAll(...i) {
      s().unsubAll(...i);
    }
  });
}
function Ce(e, t2) {
  return As(e, t2);
}
function h(e, t2) {
  return Fi(e, t2);
}
function b(e, t2) {
  const n2 = Ce(e, t2);
  return [n2, h(n2)];
}
var Ms = false;
var [zt, Af] = Vi("SDK", {
  bgColor: "forestgreen",
  textColor: "white",
  shouldLog() {
    return Ms;
  }
});
function Mf(e) {
  Ms = e, gi(e);
}
var kt = Ce(0);
var Ps = Ce(hn);
var [Cr, gn] = b({
  tgWebAppPlatform: "unknown",
  tgWebAppVersion: "0.0"
});
var se = h(() => gn().tgWebAppVersion);
function Wi(e) {
  e || (e = {});
  const { postEvent: t2 } = e, n2 = e.launchParams || bn();
  Cr.set(n2), Ps.set(
    typeof t2 == "function" ? t2 : qi(n2.tgWebAppVersion)
  ), zt(false, "The package was configured. Launch params:", Cr());
}
function xs() {
  return kt.set(kt() + 1), kt().toString();
}
function ke(e, t2, n2) {
  return Di(e, t2, xs(), {
    ...n2 || {},
    postEvent: _
  });
}
var S = (e, t2, n2) => (n2 || (n2 = {}), n2.postEvent || (n2.postEvent = _), _n(e, t2, n2));
var _ = (e, t2) => Ps()(e, t2);
function G(e) {
  return h(() => de(e, se()));
}
function Ui(e) {
  return (t2) => t2 instanceof e;
}
function Y(e, t2) {
  t2 || (t2 = []);
  class n2 extends Error {
    constructor(...s) {
      const o = typeof t2 == "function" ? t2(...s) : typeof t2 == "string" ? [t2] : t2 || [];
      super(...o), this.name = e;
    }
  }
  return Object.defineProperty(n2, "name", { value: e }), [n2, Ui(n2)];
}
function fe(e) {
  return [e];
}
var [
  vn,
  Pf
] = Y("CSSVarsBoundError", "CSS variables are already bound");
var [
  Ts,
  xf
] = Y("NotAvailableError", fe);
var [
  Tf,
  Bf
] = Y("InvalidEnvError", fe);
var [
  Pe,
  Of
] = Y("FunctionNotAvailableError", fe);
var [
  J,
  If
] = Y(
  "InvalidArgumentsError",
  (e, t2) => [e, { cause: t2 }]
);
var [
  zi,
  jf
] = Y("ConcurrentCallError", fe);
var [
  Gi,
  qf
] = Y(
  "SetEmojiStatusError",
  (e) => [`Failed to set emoji status: ${e}`]
);
var [
  Bs,
  Df
] = Y("AccessDeniedError", fe);
var [
  Qi,
  Nf
] = Y("FullscreenFailedError", fe);
var [
  Ji,
  Vf
] = Y("ShareMessageError", fe);
function kr() {
  return typeof window > "u";
}
function C(e, t2, n2) {
  n2 || (n2 = {});
  const {
    isSupported: r,
    isMounted: s,
    isMounting: o,
    component: a,
    supports: i
  } = n2 || {}, u = `${a ? `${a}.` : ""}${e}()`, c = r ? Array.isArray(r) || typeof r == "object" && "any" in r ? r : [r] : void 0;
  function l(E) {
    if (i) {
      const $ = i[E];
      return de($[0], $[1], se());
    }
    return true;
  }
  function p() {
    if (!c)
      return;
    function E(V) {
      return typeof V == "function" ? V() : de(V, se()) ? void 0 : `it is unsupported in Mini Apps version ${se()}`;
    }
    const $ = Array.isArray(c) ? c : c.any, I = $.map(E).filter(Boolean);
    return Array.isArray(c) ? I[0] : I.length === $.length ? I[I.length - 1] : void 0;
  }
  function m(...E) {
    for (const $ in i)
      if (i[$][2](...E) && !l($))
        return `option ${$} is not supported in Mini Apps version ${se()}`;
  }
  let f;
  if (i) {
    f = {};
    for (const E in i)
      f[E] = h(() => l(E));
  }
  const A = h(() => !p()), be = h(() => se() !== "0.0"), M = h(() => !s || s()), ne = h(
    () => $r() && !kr() && be() && A() && M()
  );
  return Object.assign(
    (...E) => {
      const $ = `Unable to call the ${u} ${a ? "method" : "function"}:`;
      if (kr() || !$r())
        throw new Pe(`${$} it can't be called outside Mini Apps`);
      if (!be())
        throw new Pe(`${$} the SDK was not initialized. Use the SDK init() function`);
      const I = p();
      if (I)
        throw new Pe(`${$} ${I}`);
      const V = m(...E);
      if (V)
        throw new Pe(`${$} ${V}`);
      if (!M()) {
        const d = o && o() ? "mounting. Wait for the mount completion" : `unmounted. Use the ${a}.mount() method`;
        throw new Pe(`${$} the component is ${d}`);
      }
      return t2(...E);
    },
    t2,
    {
      isAvailable: ne,
      ifAvailable(...E) {
        return ne() ? [true, t2(...E)] : [false];
      }
    },
    c ? { isSupported: A } : {},
    f ? { supports: f } : {}
  );
}
function nt(e, t2) {
  return t2 || (t2 = {}), (n2, r, s, o) => C(n2, r, {
    ...t2,
    isSupported: s || t2.isSupported,
    supports: o,
    component: e
  });
}
function ce(e, t2, n2) {
  return nt(e, { isSupported: n2, isMounted: t2 });
}
function N(e, t2) {
  return nt(e, { isSupported: t2 });
}
var rt = "web_app_setup_back_button";
var Os = "back_button_pressed";
var st = "backButton";
var [Ar, Ki] = b(false);
var [Ge, Yi] = b(false);
var Zi = G(rt);
var Is = ce(st, Ge, rt);
var wn = N(st, rt);
var Xi = Is("hide", () => {
  En(false);
});
var eu = wn("mount", () => {
  Ge() || (En(z() && U(st) || false), Ge.set(true));
});
function En(e) {
  e !== Ar() && (_(rt, { is_visible: e }), W(st, e), Ar.set(e));
}
var tu = wn(
  "onClick",
  (e) => k(Os, e)
);
var nu = wn(
  "offClick",
  (e) => {
    B(Os, e);
  }
);
var ru = Is("show", () => {
  En(true);
});
function su() {
  Ge.set(false);
}
var Lf = Object.freeze(Object.defineProperty({
  __proto__: null,
  hide: Xi,
  isMounted: Yi,
  isSupported: Zi,
  isVisible: Ki,
  mount: eu,
  offClick: nu,
  onClick: tu,
  show: ru,
  unmount: su
}, Symbol.toStringTag, { value: "Module" }));
var ou = Object.defineProperty;
var au = (e, t2, n2) => t2 in e ? ou(e, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e[t2] = n2;
var Gt = (e, t2, n2) => au(e, typeof t2 != "symbol" ? t2 + "" : t2, n2);
function iu(e) {
  return (t2) => t2 instanceof e;
}
function js(e, t2) {
  t2 || (t2 = []);
  class n2 extends Error {
    constructor(...s) {
      const o = typeof t2 == "function" ? t2(...s) : typeof t2 == "string" ? [t2] : t2 || [];
      super(...o), this.name = e;
    }
  }
  return Object.defineProperty(n2, "name", { value: e }), [n2, iu(n2)];
}
var [uu, cu] = js("CancelledError", "Promise was canceled");
var [lu, Rf] = js(
  "TimeoutError",
  (e, t2) => [`Timeout reached: ${e}ms`, { cause: t2 }]
);
var qs = Symbol("Resolved");
function Mr(e) {
  return Array.isArray(e) && e[0] === qs;
}
function pu(e) {
  return [qs, e];
}
function Pr(e, t2) {
  return e.reject = t2.reject, e.abort = t2.abort, e;
}
var x = class Qt extends Promise {
  constructor(t2, n2) {
    let r, s;
    super((o, a) => {
      let i, u;
      typeof t2 == "function" ? (i = t2, u = n2) : u = t2;
      const c = [], l = (d) => (...j) => {
        const ee = d(...j);
        return c.forEach(($t) => $t()), ee;
      }, p = new AbortController(), { signal: m } = p;
      s = (d) => {
        !m.aborted && p.abort(d);
      };
      const f = () => m.reason, A = (d) => {
        const j = () => {
          d(f());
        };
        m.addEventListener("abort", j, true);
        const ee = () => {
          m.removeEventListener("abort", j, true);
        };
        return c.push(ee), ee;
      }, be = l((d) => {
        o(d), s(pu(d));
      });
      r = l((d) => {
        a(d), s(d);
      }), u || (u = {});
      const { abortSignal: M, rejectOnAbort: ne = true } = u;
      if (M)
        if (M.aborted) {
          const { reason: d } = M;
          if (ne)
            return r(d);
          s(d);
        } else {
          const d = () => {
            s(M.reason);
          };
          M.addEventListener("abort", d), c.push(() => {
            M.removeEventListener("abort", d);
          });
        }
      ne && A(a);
      const { timeout: E } = u;
      if (E) {
        const d = setTimeout(() => {
          s(new lu(E));
        }, E);
        c.push(() => {
          clearTimeout(d);
        });
      }
      const $ = () => m.aborted, I = () => Mr(f()), V = () => {
        const d = f();
        return Mr(d) ? d[1] : void 0;
      };
      try {
        const d = i && i(be, r, {
          abortReason: f,
          abortSignal: m,
          isAborted: $,
          isResolved: I,
          onAborted: A,
          onResolved: (j) => A(() => {
            I() && j(V());
          }),
          resolved: V,
          throwIfAborted() {
            if ($())
              throw f();
          }
        });
        d instanceof Promise && d.catch(r);
      } catch (d) {
        r(d);
      }
    }), Gt(this, "abort"), Gt(this, "reject"), this.abort = s, this.reject = r;
  }
  /**
   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(t2, n2) {
    return new Qt(async (r, s, o) => {
      try {
        r(await t2(o));
      } catch (a) {
        s(a);
      }
    }, n2);
  }
  static resolve(t2) {
    return this.fn(() => t2);
  }
  /**
   * @see Promise.reject
   */
  static reject(t2) {
    return new Qt((n2, r) => {
      r(t2);
    });
  }
  /**
   * Aborts the promise with the cancel error.
   */
  cancel() {
    this.abort(new uu());
  }
  /**
   * @see Promise.catch
   */
  catch(t2) {
    return this.then(void 0, t2);
  }
  /**
   * @see Promise.finally
   */
  finally(t2) {
    return Pr(super.finally(t2), this);
  }
  /**
   * @see Promise.then
   */
  then(t2, n2) {
    return Pr(super.then(t2, n2), this);
  }
};
function xr(e, t2) {
  return e.resolve = t2.resolve, e;
}
var du = class Jt extends x {
  constructor(t2, n2) {
    let r, s;
    typeof t2 == "function" ? (r = t2, s = n2) : s = t2;
    let o;
    super((a, i, u) => {
      o = a, r && r(a, i, u);
    }, s), Gt(this, "resolve"), this.resolve = o;
  }
  /**
   * Creates a new ManualPromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(t2, n2) {
    return new Jt((r, s, o) => {
      try {
        Promise.resolve(t2(o)).then(r, s);
      } catch (a) {
        s(a);
      }
    }, n2);
  }
  static resolve(t2) {
    return this.fn(() => t2);
  }
  /**
   * @see Promise.reject
   */
  static reject(t2) {
    return new Jt((n2, r) => {
      r(t2);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(t2) {
    return this.then(void 0, t2);
  }
  /**
   * @see Promise.finally
   */
  finally(t2) {
    return xr(super.finally(t2), this);
  }
  /**
   * @see Promise.then
   */
  then(t2, n2) {
    return xr(super.then(t2, n2), this);
  }
};
function O(e, t2, n2) {
  n2 || (n2 = {});
  const {
    promise: r,
    error: s
  } = n2, [o, a] = r ? [r, h(r)] : b(), [i, u] = s ? [s, h(s)] : b();
  return [
    Object.assign((...c) => {
      if (o()) {
        const p = new zi(t2);
        return i.set(p), x.reject(p);
      }
      Ut(() => {
        o.set(e(...c)), i.set(void 0);
      });
      let l;
      return o().catch((p) => {
        throw l = p, p;
      }).finally(() => {
        Ut(() => {
          o.set(void 0), i.set(l);
        });
      });
    }, e),
    [o, a, h(() => !!o())],
    [i, u]
  ];
}
function Le(e, t2, n2) {
  const [r, ...s] = O(t2, `The ${e} component is already mounting`), [o, a] = b(false);
  return [
    (...i) => o() ? x.resolve() : r(...i).then((u) => {
      Ut(() => {
        o.set(true), n2(u);
      });
    }),
    ...s,
    [o, a]
  ];
}
var [$n, fu] = b({
  available: false,
  type: "",
  accessGranted: false,
  accessRequested: false,
  deviceId: "",
  tokenSaved: false
});
var mu = h(() => $n().available);
var Tr = "web_app_biometry_get_info";
var hu = C(
  "requestBiometry",
  (e) => S(Tr, "biometry_info_received", e),
  { isSupported: Tr }
);
function Ds(e) {
  if (!cu(e))
    throw e;
}
function Ae(e) {
  const t2 = e();
  t2 && t2.catch(Ds).cancel();
}
var De = "biometry";
var ot = "web_app_biometry_request_auth";
var Sn = "biometry_info_received";
var Ns = (e) => {
  at(Cn(e));
};
function Vs() {
  throw new Ts("Biometry is not available");
}
function Cn(e) {
  let t2 = false, n2 = false, r = "", s = false, o = "", a = false;
  return e.available && (t2 = true, n2 = e.token_saved, r = e.device_id, s = e.access_requested, o = e.type, a = e.access_granted), { available: t2, tokenSaved: n2, deviceId: r, type: o, accessGranted: a, accessRequested: s };
}
var _u = G(ot);
var [
  bu,
  yu,
  gu,
  Ls
] = Le(
  De,
  (e) => {
    const t2 = z() && U(De);
    return t2 ? x.resolve(t2) : hu({ abortSignal: e }).then(Cn);
  },
  (e) => {
    k(Sn, Ns), at(e);
  }
);
var Rs = N(De, ot);
var kn = ce(De, Ls[0], ot);
var vu = Rs("mount", bu);
var [, Hs, wu] = yu;
var [, Eu] = gu;
var [$u, Su] = Ls;
var [
  Cu,
  ku,
  Au
] = O(
  (e) => x.fn(async (t2) => {
    const n2 = $n();
    n2.available || Vs();
    const r = await S(ot, "biometry_auth_requested", {
      ...e,
      ...t2,
      params: { reason: ((e || {}).reason || "").trim() }
    }), { token: s } = r;
    return typeof s == "string" && at({ ...n2, token: s }), r;
  }, e),
  "Biometry authentication is already in progress"
);
var Mu = kn("authenticate", Cu);
var [, Fs, Pu] = ku;
var [, xu] = Au;
var Tu = Rs("openSettings", () => {
  _("web_app_biometry_open_settings");
});
var [
  Bu,
  Ou,
  Iu
] = O(
  (e) => x.fn(async (t2) => {
    const n2 = await S("web_app_biometry_request_access", Sn, {
      ...e,
      ...t2,
      params: { reason: (e || {}).reason || "" }
    }).then(Cn);
    return n2.available || Vs(), at(n2), n2.accessGranted;
  }, e),
  "Biometry access request is already in progress"
);
var ju = kn("requestAccess", Bu);
var [, Ws, qu] = Ou;
var [, Du] = Iu;
function at(e) {
  $n.set(e), W(De, e);
}
function Nu() {
  [Fs, Ws, Hs].forEach(Ae), B(Sn, Ns), $u.set(false);
}
var Vu = kn(
  "updateToken",
  (e) => (e || (e = {}), S("web_app_biometry_update_token", "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t2) => t2.status))
);
var Hf = Object.freeze(Object.defineProperty({
  __proto__: null,
  authError: xu,
  authPromise: Fs,
  authenticate: Mu,
  isAuthenticating: Pu,
  isAvailable: mu,
  isMounted: Su,
  isMounting: wu,
  isRequestingAccess: qu,
  isSupported: _u,
  mount: vu,
  mountError: Eu,
  mountPromise: Hs,
  openSettings: Tu,
  requestAccess: ju,
  requestAccessError: Du,
  requestAccessPromise: Ws,
  state: fu,
  unmount: Nu,
  updateToken: Vu
}, Symbol.toStringTag, { value: "Module" }));
function it(e, t2) {
  return nt(e, { isMounted: t2 });
}
var le = nt;
var ut = "closingBehavior";
var [Br, Lu] = b(false);
var [Kt, Us] = b(false);
var zs = it(ut, Us);
var Ru = le(ut);
var Hu = zs("disableConfirmation", () => {
  An(false);
});
var Fu = zs("enableConfirmation", () => {
  An(true);
});
var Wu = Ru("mount", () => {
  Kt() || (An(
    z() && U(ut) || false
  ), Kt.set(true));
});
function An(e) {
  e !== Br() && (_("web_app_setup_closing_behavior", { need_confirmation: e }), W(ut, e), Br.set(e));
}
function Uu() {
  Kt.set(false);
}
var Ff = Object.freeze(Object.defineProperty({
  __proto__: null,
  disableConfirmation: Hu,
  enableConfirmation: Fu,
  isConfirmationEnabled: Lu,
  isMounted: Us,
  mount: Wu,
  unmount: Uu
}, Symbol.toStringTag, { value: "Module" }));
var te;
function Gs(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (te == null ? void 0 : te.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (te == null ? void 0 : te.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (te == null ? void 0 : te.abortPipeEarly)
  };
}
var At;
function zu(e) {
  return At == null ? void 0 : At.get(e);
}
var Mt;
function Gu(e) {
  return Mt == null ? void 0 : Mt.get(e);
}
var Pt;
function Qu(e, t2) {
  var n2;
  return (n2 = Pt == null ? void 0 : Pt.get(e)) == null ? void 0 : n2.get(t2);
}
function Ju(e) {
  var n2, r;
  const t2 = typeof e;
  return t2 === "string" ? `"${e}"` : t2 === "number" || t2 === "bigint" || t2 === "boolean" ? `${e}` : t2 === "object" || t2 === "function" ? (e && ((r = (n2 = Object.getPrototypeOf(e)) == null ? void 0 : n2.constructor) == null ? void 0 : r.name)) ?? "null" : t2;
}
function L(e, t2, n2, r, s) {
  const o = s && "input" in s ? s.input : n2.value, a = (s == null ? void 0 : s.expected) ?? e.expects ?? null, i = (s == null ? void 0 : s.received) ?? Ju(o), u = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: a,
    received: i,
    message: `Invalid ${t2}: ${a ? `Expected ${a} but r` : "R"}eceived ${i}`,
    requirement: e.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, c = e.kind === "schema", l = (s == null ? void 0 : s.message) ?? e.message ?? Qu(e.reference, u.lang) ?? (c ? Gu(u.lang) : null) ?? r.message ?? zu(u.lang);
  l && (u.message = typeof l == "function" ? (
    // @ts-expect-error
    l(u)
  ) : l), c && (n2.typed = false), n2.issues ? n2.issues.push(u) : n2.issues = [u];
}
function Z(e) {
  return {
    version: 1,
    vendor: "valibot",
    validate(t2) {
      return e["~run"]({ value: t2 }, Gs());
    }
  };
}
function Qs(e, t2) {
  return Object.hasOwn(e, t2) && t2 !== "__proto__" && t2 !== "prototype" && t2 !== "constructor";
}
function Ku(e, t2) {
  const n2 = [...new Set(e)];
  return n2.length > 1 ? `(${n2.join(` ${t2} `)})` : n2[0] ?? "never";
}
var Yt = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), this.name = "ValiError", this.issues = e;
  }
};
function Js(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: Js,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    "~run"(t2, n2) {
      return t2.typed && !this.requirement(t2.value) && L(this, "integer", t2, n2), t2;
    }
  };
}
function Mn(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: Mn,
    async: false,
    operation: e,
    "~run"(t2) {
      return t2.value = this.operation(t2.value), t2;
    }
  };
}
function Ks(e, t2, n2) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t2, n2)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Ys(e, t2) {
  return {
    kind: "schema",
    type: "array",
    reference: Ys,
    expects: "Array",
    async: false,
    item: e,
    message: t2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(n2, r) {
      var o;
      const s = n2.value;
      if (Array.isArray(s)) {
        n2.typed = true, n2.value = [];
        for (let a = 0; a < s.length; a++) {
          const i = s[a], u = this.item["~run"]({ value: i }, r);
          if (u.issues) {
            const c = {
              type: "array",
              origin: "value",
              input: s,
              key: a,
              value: i
            };
            for (const l of u.issues)
              l.path ? l.path.unshift(c) : l.path = [c], (o = n2.issues) == null || o.push(l);
            if (n2.issues || (n2.issues = u.issues), r.abortEarly) {
              n2.typed = false;
              break;
            }
          }
          u.typed || (n2.typed = false), n2.value.push(u.value);
        }
      } else
        L(this, "type", n2, r);
      return n2;
    }
  };
}
function Pn(e) {
  return {
    kind: "schema",
    type: "date",
    reference: Pn,
    expects: "Date",
    async: false,
    message: e,
    get "~standard"() {
      return Z(this);
    },
    "~run"(t2, n2) {
      return t2.value instanceof Date ? isNaN(t2.value) ? L(this, "type", t2, n2, {
        received: '"Invalid Date"'
      }) : t2.typed = true : L(this, "type", t2, n2), t2;
    }
  };
}
function Zs(e, t2) {
  return {
    kind: "schema",
    type: "instance",
    reference: Zs,
    expects: e.name,
    async: false,
    class: e,
    message: t2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(n2, r) {
      return n2.value instanceof this.class ? n2.typed = true : L(this, "type", n2, r), n2;
    }
  };
}
function Zt(e, t2) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: Zt,
    expects: "Object",
    async: false,
    entries: e,
    message: t2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(n2, r) {
      var o;
      const s = n2.value;
      if (s && typeof s == "object") {
        n2.typed = true, n2.value = {};
        for (const a in this.entries) {
          const i = this.entries[a];
          if (a in s || (i.type === "exact_optional" || i.type === "optional" || i.type === "nullish") && // @ts-expect-error
          i.default !== void 0) {
            const u = a in s ? (
              // @ts-expect-error
              s[a]
            ) : Ks(i), c = i["~run"]({ value: u }, r);
            if (c.issues) {
              const l = {
                type: "object",
                origin: "value",
                input: s,
                key: a,
                value: u
              };
              for (const p of c.issues)
                p.path ? p.path.unshift(l) : p.path = [l], (o = n2.issues) == null || o.push(p);
              if (n2.issues || (n2.issues = c.issues), r.abortEarly) {
                n2.typed = false;
                break;
              }
            }
            c.typed || (n2.typed = false), n2.value[a] = c.value;
          } else if (i.type !== "exact_optional" && i.type !== "optional" && i.type !== "nullish" && (L(this, "key", n2, r, {
            input: void 0,
            expected: `"${a}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: s,
                key: a,
                // @ts-expect-error
                value: s[a]
              }
            ]
          }), r.abortEarly))
            break;
        }
        if (!n2.issues || !r.abortEarly)
          for (const a in s)
            Qs(s, a) && !(a in this.entries) && (n2.value[a] = s[a]);
      } else
        L(this, "type", n2, r);
      return n2;
    }
  };
}
function xn(e) {
  return {
    kind: "schema",
    type: "number",
    reference: xn,
    expects: "number",
    async: false,
    message: e,
    get "~standard"() {
      return Z(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "number" && !isNaN(t2.value) ? t2.typed = true : L(this, "type", t2, n2), t2;
    }
  };
}
function Xs(e, t2) {
  return {
    kind: "schema",
    type: "optional",
    reference: Xs,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    default: t2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(n2, r) {
      return n2.value === void 0 && (this.default !== void 0 && (n2.value = Ks(this, n2, r)), n2.value === void 0) ? (n2.typed = true, n2) : this.wrapped["~run"](n2, r);
    }
  };
}
function eo(e, t2, n2) {
  return {
    kind: "schema",
    type: "record",
    reference: eo,
    expects: "Object",
    async: false,
    key: e,
    value: t2,
    message: n2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(r, s) {
      var a, i;
      const o = r.value;
      if (o && typeof o == "object") {
        r.typed = true, r.value = {};
        for (const u in o)
          if (Qs(o, u)) {
            const c = o[u], l = this.key["~run"]({ value: u }, s);
            if (l.issues) {
              const m = {
                type: "object",
                origin: "key",
                input: o,
                key: u,
                value: c
              };
              for (const f of l.issues)
                f.path = [m], (a = r.issues) == null || a.push(f);
              if (r.issues || (r.issues = l.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            const p = this.value["~run"](
              { value: c },
              s
            );
            if (p.issues) {
              const m = {
                type: "object",
                origin: "value",
                input: o,
                key: u,
                value: c
              };
              for (const f of p.issues)
                f.path ? f.path.unshift(m) : f.path = [m], (i = r.issues) == null || i.push(f);
              if (r.issues || (r.issues = p.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            (!l.typed || !p.typed) && (r.typed = false), l.typed && (r.value[l.value] = p.value);
          }
      } else
        L(this, "type", r, s);
      return r;
    }
  };
}
function H(e) {
  return {
    kind: "schema",
    type: "string",
    reference: H,
    expects: "string",
    async: false,
    message: e,
    get "~standard"() {
      return Z(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "string" ? t2.typed = true : L(this, "type", t2, n2), t2;
    }
  };
}
function Or(e) {
  let t2;
  if (e)
    for (const n2 of e)
      t2 ? t2.push(...n2.issues) : t2 = n2.issues;
  return t2;
}
function to(e, t2) {
  return {
    kind: "schema",
    type: "union",
    reference: to,
    expects: Ku(
      e.map((n2) => n2.expects),
      "|"
    ),
    async: false,
    options: e,
    message: t2,
    get "~standard"() {
      return Z(this);
    },
    "~run"(n2, r) {
      let s, o, a;
      for (const i of this.options) {
        const u = i["~run"]({ value: n2.value }, r);
        if (u.typed)
          if (u.issues)
            o ? o.push(u) : o = [u];
          else {
            s = u;
            break;
          }
        else
          a ? a.push(u) : a = [u];
      }
      if (s)
        return s;
      if (o) {
        if (o.length === 1)
          return o[0];
        L(this, "type", n2, r, {
          issues: Or(o)
        }), n2.typed = true;
      } else {
        if ((a == null ? void 0 : a.length) === 1)
          return a[0];
        L(this, "type", n2, r, {
          issues: Or(a)
        });
      }
      return n2;
    }
  };
}
function ct(e, t2, n2) {
  const r = e["~run"]({ value: t2 }, Gs(n2));
  if (r.issues)
    throw new Yt(r.issues);
  return r.value;
}
function Ue(...e) {
  return {
    ...e[0],
    pipe: e,
    get "~standard"() {
      return Z(this);
    },
    "~run"(t2, n2) {
      for (const r of e)
        if (r.kind !== "metadata") {
          if (t2.issues && (r.kind === "schema" || r.kind === "transformation")) {
            t2.typed = false;
            break;
          }
          (!t2.issues || !n2.abortEarly && !n2.abortPipeEarly) && (t2 = r["~run"](t2, n2));
        }
      return t2;
    }
  };
}
var no = "web_app_invoke_custom_method";
var Re = N("cloudStorage", no);
var Yu = G(no);
var ro = Re("deleteItem", (e, t2) => {
  const n2 = Array.isArray(e) ? e : [e];
  return n2.length ? ke("deleteStorageValues", { keys: n2 }, t2).then() : x.resolve();
});
function Zu(e, t2) {
  const n2 = Array.isArray(e) ? e : [e];
  return n2.length ? ke("getStorageValues", { keys: n2 }, t2).then((r) => {
    const s = {
      // Fulfill the response with probably missing keys.
      ...n2.reduce((o, a) => (o[a] = "", o), {}),
      ...ct(eo(H(), H()), r)
    };
    return typeof e == "string" ? s[e] : s;
  }) : x.resolve(Array.isArray(e) ? {} : "");
}
var Xu = Re("getItem", Zu);
var so = Re("getKeys", (e) => ke("getStorageKeys", {}, e).then(
  (t2) => ct(Ys(H()), t2)
));
var ec = Re("setItem", (e, t2, n2) => ke("saveStorageValue", {
  key: e,
  value: t2
}, n2).then());
var tc = Re("clear", (e) => so(e).then(ro));
var Wf = Object.freeze(Object.defineProperty({
  __proto__: null,
  clear: tc,
  deleteItem: ro,
  getItem: Xu,
  getKeys: so,
  isSupported: Yu,
  setItem: ec
}, Symbol.toStringTag, { value: "Module" }));
var He = "web_app_trigger_haptic_feedback";
var Tn = N("hapticFeedback", He);
var nc = G(He);
var rc = Tn(
  "impactOccurred",
  (e) => {
    _(He, {
      type: "impact",
      impact_style: e
    });
  }
);
var sc = Tn(
  "notificationOccurred",
  (e) => {
    _(He, {
      type: "notification",
      notification_type: e
    });
  }
);
var oc = Tn(
  "selectionChanged",
  () => {
    _(He, { type: "selection_change" });
  }
);
var Uf = Object.freeze(Object.defineProperty({
  __proto__: null,
  impactOccurred: rc,
  isSupported: nc,
  notificationOccurred: sc,
  selectionChanged: oc
}, Symbol.toStringTag, { value: "Module" }));
var [oo, ac] = b(void 0);
function X(e) {
  return h(() => {
    const t2 = oo();
    return t2 ? t2[e] : void 0;
  });
}
var ao = X("auth_date");
var io = X("can_send_after");
var ic = h(() => {
  const e = ao(), t2 = io();
  return t2 && e ? new Date(e.getTime() + t2 * 1e3) : void 0;
});
var uc = X("chat");
var cc = X("chat_type");
var lc = X("chat_instance");
var pc = X("hash");
var dc = X("query_id");
var [fc, mc] = b();
var hc = X("receiver");
function _c() {
  const e = bn();
  oo.set(e.tgWebAppData), fc.set(Ii());
}
var bc = X("start_param");
var yc = X("user");
var zf = Object.freeze(Object.defineProperty({
  __proto__: null,
  authDate: ao,
  canSendAfter: io,
  canSendAfterDate: ic,
  chat: uc,
  chatInstance: lc,
  chatType: cc,
  hash: pc,
  queryId: dc,
  raw: mc,
  receiver: hc,
  restore: _c,
  startParam: bc,
  state: ac,
  user: yc
}, Symbol.toStringTag, { value: "Module" }));
var Bn = "web_app_open_invoice";
var gc = N("invoice", Bn);
var vc = G(Bn);
function wc(e, t2, n2) {
  let r;
  if (t2 === "url") {
    const { hostname: s, pathname: o } = new URL(e, window.location.href);
    if (s !== "t.me")
      throw new J(`Link has unexpected hostname: ${s}`);
    const a = o.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new J(
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , r] = a;
  } else
    r = e, n2 = t2;
  return S(Bn, "invoice_closed", {
    ...n2,
    params: { slug: r },
    capture: (s) => r === s.slug
  }).then((s) => s.status);
}
var [
  Ec,
  $c,
  Sc
] = O(wc, "Invoice is already opened");
var Cc = gc("open", Ec);
var [, kc, Ac] = $c;
var [, Mc] = Sc;
var Gf = Object.freeze(Object.defineProperty({
  __proto__: null,
  isOpened: Ac,
  isSupported: vc,
  open: Cc,
  openError: Mc,
  openPromise: kc
}, Symbol.toStringTag, { value: "Module" }));
var Ie = "locationManager";
var On = "web_app_check_location";
var Ir = "web_app_open_location_settings";
var Qe = Ce({
  available: false,
  accessGranted: false,
  accessRequested: false
});
function In(e) {
  return h(() => Qe()[e]);
}
var Pc = G(On);
var xc = In("available");
var Tc = In("accessGranted");
var Bc = In("accessRequested");
function Oc(e) {
  let t2 = false, n2, r;
  return e.available && (t2 = true, n2 = e.access_requested, r = e.access_granted), {
    available: t2,
    accessGranted: r || false,
    accessRequested: n2 || false
  };
}
var [
  Ic,
  jc,
  qc,
  uo
] = Le(
  Ie,
  (e) => {
    const t2 = z() && U(Ie);
    return t2 ? x.resolve(t2) : S("web_app_check_location", "location_checked", e).then(Oc);
  },
  (e) => {
    Qe.set(e), W(Ie, e);
  }
);
var co = N(Ie, On);
var Dc = ce(Ie, uo[0], On);
var Nc = co("mount", Ic);
var [, Vc, Lc] = jc;
var [, Rc] = qc;
var [Hc, Fc] = uo;
var [
  Wc,
  Uc,
  zc
] = O(
  (e) => S("web_app_request_location", "location_requested", e).then((t2) => {
    if (!t2.available)
      throw Qe.set({ ...Qe(), available: false }), new Ts("Location data tracking is not available");
    const { available: n2, ...r } = t2;
    return r;
  }),
  "Location request is currently in progress"
);
var Gc = Dc("requestLocation", Wc);
var [, lo, Qc] = Uc;
var [, Jc] = zc;
var Kc = co("openSettings", () => {
  _(Ir);
}, Ir);
function Yc() {
  Ae(lo), Hc.set(false);
}
var Qf = Object.freeze(Object.defineProperty({
  __proto__: null,
  isAccessGranted: Tc,
  isAccessRequested: Bc,
  isAvailable: xc,
  isMounted: Fc,
  isMounting: Lc,
  isRequestingLocation: Qc,
  isSupported: Pc,
  mount: Nc,
  mountError: Rc,
  mountPromise: Vc,
  openSettings: Kc,
  requestLocation: Gc,
  requestLocationError: Jc,
  requestLocationPromise: lo,
  unmount: Yc
}, Symbol.toStringTag, { value: "Module" }));
function jn(e) {
  const t2 = {};
  for (const n2 in e) {
    const r = e[n2];
    r !== void 0 && (t2[n2] = r);
  }
  return t2;
}
function po(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function Zc(e, t2) {
  var n2;
  return (n2 = void 0) == null ? void 0 : n2.get(t2);
}
function Xc(e) {
  var t2, n2;
  const r = typeof e;
  return r === "string" ? `"${e}"` : r === "number" || r === "bigint" || r === "boolean" ? `${e}` : r === "object" || r === "function" ? (e && ((n2 = (t2 = Object.getPrototypeOf(e)) == null ? void 0 : t2.constructor) == null ? void 0 : n2.name)) ?? "null" : r;
}
function D(e, t2, n2, r, s) {
  const o = s && "input" in s ? s.input : n2.value, a = (s == null ? void 0 : s.expected) ?? e.expects ?? null, i = (s == null ? void 0 : s.received) ?? Xc(o), u = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: a,
    received: i,
    message: `Invalid ${t2}: ${a ? `Expected ${a} but r` : "R"}eceived ${i}`,
    requirement: e.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, c = e.kind === "schema", l = (s == null ? void 0 : s.message) ?? e.message ?? Zc(e.reference, u.lang) ?? (c ? (u.lang, void 0) : null) ?? r.message ?? (u.lang, void 0);
  l && (u.message = typeof l == "function" ? (
    // @ts-expect-error
    l(u)
  ) : l), c && (n2.typed = false), n2.issues ? n2.issues.push(u) : n2.issues = [u];
}
function Q(e) {
  return {
    version: 1,
    vendor: "valibot",
    validate(t2) {
      return e["~run"]({ value: t2 }, po());
    }
  };
}
function fo(e, t2) {
  return Object.hasOwn(e, t2) && t2 !== "__proto__" && t2 !== "prototype" && t2 !== "constructor";
}
function el(e, t2) {
  const n2 = [...new Set(e)];
  return n2.length > 1 ? `(${n2.join(` ${t2} `)})` : n2[0] ?? "never";
}
var tl = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), this.name = "ValiError", this.issues = e;
  }
};
function mo(e, t2) {
  return {
    kind: "validation",
    type: "check",
    reference: mo,
    async: false,
    expects: null,
    requirement: e,
    message: t2,
    "~run"(n2, r) {
      return n2.typed && !this.requirement(n2.value) && D(this, "input", n2, r), n2;
    }
  };
}
function ho(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: ho,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    "~run"(t2, n2) {
      return t2.typed && !this.requirement(t2.value) && D(this, "integer", t2, n2), t2;
    }
  };
}
function ie(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: ie,
    async: false,
    operation: e,
    "~run"(t2) {
      return t2.value = this.operation(t2.value), t2;
    }
  };
}
function _o(e, t2, n2) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t2, n2)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Be(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: Be,
    expects: "boolean",
    async: false,
    message: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "boolean" ? t2.typed = true : D(this, "type", t2, n2), t2;
    }
  };
}
function bo(e) {
  return {
    kind: "schema",
    type: "date",
    reference: bo,
    expects: "Date",
    async: false,
    message: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      return t2.value instanceof Date ? isNaN(t2.value) ? D(this, "type", t2, n2, {
        received: '"Invalid Date"'
      }) : t2.typed = true : D(this, "type", t2, n2), t2;
    }
  };
}
function yo(e, t2) {
  return {
    kind: "schema",
    type: "instance",
    reference: yo,
    expects: e.name,
    async: false,
    class: e,
    message: t2,
    get "~standard"() {
      return Q(this);
    },
    "~run"(n2, r) {
      return n2.value instanceof this.class ? n2.typed = true : D(this, "type", n2, r), n2;
    }
  };
}
function qn(e) {
  return {
    kind: "schema",
    type: "lazy",
    reference: qn,
    expects: "unknown",
    async: false,
    getter: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      return this.getter(t2.value)["~run"](t2, n2);
    }
  };
}
function Fe(e, t2) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: Fe,
    expects: "Object",
    async: false,
    entries: e,
    message: t2,
    get "~standard"() {
      return Q(this);
    },
    "~run"(n2, r) {
      var s;
      const o = n2.value;
      if (o && typeof o == "object") {
        n2.typed = true, n2.value = {};
        for (const a in this.entries) {
          const i = this.entries[a];
          if (a in o || (i.type === "exact_optional" || i.type === "optional" || i.type === "nullish") && // @ts-expect-error
          i.default !== void 0) {
            const u = a in o ? (
              // @ts-expect-error
              o[a]
            ) : _o(i), c = i["~run"]({ value: u }, r);
            if (c.issues) {
              const l = {
                type: "object",
                origin: "value",
                input: o,
                key: a,
                value: u
              };
              for (const p of c.issues)
                p.path ? p.path.unshift(l) : p.path = [l], (s = n2.issues) == null || s.push(p);
              if (n2.issues || (n2.issues = c.issues), r.abortEarly) {
                n2.typed = false;
                break;
              }
            }
            c.typed || (n2.typed = false), n2.value[a] = c.value;
          } else if (i.type !== "exact_optional" && i.type !== "optional" && i.type !== "nullish" && (D(this, "key", n2, r, {
            input: void 0,
            expected: `"${a}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: o,
                key: a,
                // @ts-expect-error
                value: o[a]
              }
            ]
          }), r.abortEarly))
            break;
        }
        if (!n2.issues || !r.abortEarly)
          for (const a in o)
            fo(o, a) && !(a in this.entries) && (n2.value[a] = o[a]);
      } else
        D(this, "type", n2, r);
      return n2;
    }
  };
}
function lt(e) {
  return {
    kind: "schema",
    type: "number",
    reference: lt,
    expects: "number",
    async: false,
    message: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "number" && !isNaN(t2.value) ? t2.typed = true : D(this, "type", t2, n2), t2;
    }
  };
}
function w(e, t2) {
  return {
    kind: "schema",
    type: "optional",
    reference: w,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    default: t2,
    get "~standard"() {
      return Q(this);
    },
    "~run"(n2, r) {
      return n2.value === void 0 && (this.default !== void 0 && (n2.value = _o(this, n2, r)), n2.value === void 0) ? (n2.typed = true, n2) : this.wrapped["~run"](n2, r);
    }
  };
}
function go(e, t2, n2) {
  return {
    kind: "schema",
    type: "record",
    reference: go,
    expects: "Object",
    async: false,
    key: e,
    value: t2,
    message: n2,
    get "~standard"() {
      return Q(this);
    },
    "~run"(r, s) {
      var o, a;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const u in i)
          if (fo(i, u)) {
            const c = i[u], l = this.key["~run"]({ value: u }, s);
            if (l.issues) {
              const m = {
                type: "object",
                origin: "key",
                input: i,
                key: u,
                value: c
              };
              for (const f of l.issues)
                f.path = [m], (o = r.issues) == null || o.push(f);
              if (r.issues || (r.issues = l.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            const p = this.value["~run"](
              { value: c },
              s
            );
            if (p.issues) {
              const m = {
                type: "object",
                origin: "value",
                input: i,
                key: u,
                value: c
              };
              for (const f of p.issues)
                f.path ? f.path.unshift(m) : f.path = [m], (a = r.issues) == null || a.push(f);
              if (r.issues || (r.issues = p.issues), s.abortEarly) {
                r.typed = false;
                break;
              }
            }
            (!l.typed || !p.typed) && (r.typed = false), l.typed && (r.value[l.value] = p.value);
          }
      } else
        D(this, "type", r, s);
      return r;
    }
  };
}
function g(e) {
  return {
    kind: "schema",
    type: "string",
    reference: g,
    expects: "string",
    async: false,
    message: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      return typeof t2.value == "string" ? t2.typed = true : D(this, "type", t2, n2), t2;
    }
  };
}
function jr(e) {
  let t2;
  if (e)
    for (const n2 of e)
      t2 ? t2.push(...n2.issues) : t2 = n2.issues;
  return t2;
}
function Dn(e, t2) {
  return {
    kind: "schema",
    type: "union",
    reference: Dn,
    expects: el(
      e.map((n2) => n2.expects),
      "|"
    ),
    async: false,
    options: e,
    message: t2,
    get "~standard"() {
      return Q(this);
    },
    "~run"(n2, r) {
      let s, o, a;
      for (const i of this.options) {
        const u = i["~run"]({ value: n2.value }, r);
        if (u.typed)
          if (u.issues)
            o ? o.push(u) : o = [u];
          else {
            s = u;
            break;
          }
        else
          a ? a.push(u) : a = [u];
      }
      if (s)
        return s;
      if (o) {
        if (o.length === 1)
          return o[0];
        D(this, "type", n2, r, {
          issues: jr(o)
        }), n2.typed = true;
      } else {
        if ((a == null ? void 0 : a.length) === 1)
          return a[0];
        D(this, "type", n2, r, {
          issues: jr(a)
        });
      }
      return n2;
    }
  };
}
function vo(e, t2, n2) {
  const r = e["~run"]({ value: t2 }, po(n2));
  if (r.issues)
    throw new tl(r.issues);
  return r.value;
}
function ue(...e) {
  return {
    ...e[0],
    pipe: e,
    get "~standard"() {
      return Q(this);
    },
    "~run"(t2, n2) {
      for (const r of e)
        if (r.kind !== "metadata") {
          if (t2.issues && (r.kind === "schema" || r.kind === "transformation")) {
            t2.typed = false;
            break;
          }
          (!t2.issues || !n2.abortEarly && !n2.abortPipeEarly) && (t2 = r["~run"](t2, n2));
        }
      return t2;
    }
  };
}
function nl(e) {
  return e.replace(/_[a-z]/g, (t2) => t2[1].toUpperCase());
}
function rl(e) {
  return Object.entries(e).reduce((t2, [n2, r]) => (t2[nl(n2)] = r, t2), {});
}
function Xt(e) {
  const t2 = rl(e);
  for (const n2 in t2) {
    const r = t2[n2];
    r && typeof r == "object" && !(r instanceof Date) && (t2[n2] = Array.isArray(r) ? r.map(Xt) : Xt(r));
  }
  return t2;
}
function Nn(e) {
  return ie((t2) => e ? Xt(t2) : t2);
}
function wo(e) {
  return (t2) => ue(
    e,
    Nn(t2)
  );
}
function Eo(e) {
  return (t2, n2) => vo(
    ue(e, Nn(n2)),
    t2
  );
}
function $o() {
  return ie(JSON.parse);
}
function Vn(e) {
  const t2 = wo(e);
  return (n2) => ue(
    g(),
    $o(),
    t2(n2)
  );
}
function So(e) {
  return ie((t2) => {
    const n2 = {};
    return new URLSearchParams(t2).forEach((r, s) => {
      const o = n2[s];
      Array.isArray(o) ? o.push(r) : o === void 0 ? n2[s] = r : n2[s] = [o, r];
    }), vo(e, n2);
  });
}
function Co(e) {
  return (t2) => ue(
    Dn([g(), yo(URLSearchParams)]),
    So(e),
    Nn(t2)
  );
}
var qr = w(qn(() => ul()));
var sl = Fe({
  id: lt(),
  photo_url: w(g()),
  type: g(),
  title: g(),
  username: w(g())
});
var ol = Fe({
  added_to_attachment_menu: w(Be()),
  allows_write_to_pm: w(Be()),
  first_name: g(),
  id: lt(),
  is_bot: w(Be()),
  is_premium: w(Be()),
  last_name: w(g()),
  language_code: w(g()),
  photo_url: w(g()),
  username: w(g())
});
var al = Fe({
  auth_date: ue(
    g(),
    ie((e) => new Date(Number(e) * 1e3)),
    bo()
  ),
  can_send_after: w(ue(g(), ie(Number), ho())),
  chat: w(qn(() => il())),
  chat_type: w(g()),
  chat_instance: w(g()),
  hash: g(),
  query_id: w(g()),
  receiver: qr,
  start_param: w(g()),
  signature: g(),
  user: qr
});
var il = Vn(sl);
var ul = Vn(ol);
var ko = Co(al);
function we(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function cl(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function ll(e) {
  const t2 = e.replace(/\s/g, "").toLowerCase();
  if (we(t2))
    return t2;
  if (cl(t2)) {
    let r = "#";
    for (let s = 0; s < 3; s += 1)
      r += t2[1 + s].repeat(2);
    return r;
  }
  const n2 = t2.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t2.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n2)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n2.slice(1).reduce((r, s) => r + parseInt(s, 10).toString(16).padStart(2, "0"), "#");
}
var pl = wo(
  go(
    g(),
    ue(
      Dn([g(), lt()]),
      ie((e) => typeof e == "number" ? `#${(e & 16777215).toString(16).padStart(6, "0")}` : e),
      mo(we)
    )
  )
);
var xt = w(
  ue(g(), ie((e) => e === "1"))
);
var Dr = Vn(pl());
var dl = Fe({
  tgWebAppBotInline: xt,
  tgWebAppData: w(ko()),
  tgWebAppDefaultColors: w(Dr()),
  tgWebAppFullscreen: xt,
  tgWebAppPlatform: g(),
  tgWebAppShowSettings: xt,
  tgWebAppStartParam: w(g()),
  tgWebAppThemeParams: Dr(),
  tgWebAppVersion: g()
});
var fl = Co(dl);
var Jf = Eo(ko());
var Kf = Eo(fl());
function Ao(e, t2) {
  return t2 || (t2 = (n2, r) => JSON.stringify(r)), new URLSearchParams(
    Object.entries(e).reduce((n2, [r, s]) => (Array.isArray(s) ? n2.push(...s.map((o) => [r, String(o)])) : s != null && n2.push([
      r,
      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == "string" || typeof s == "number" ? String(s) : typeof s == "boolean" ? s ? "1" : "0" : t2(r, s)
    ]), n2), [])
  ).toString();
}
function ml(e) {
  return Ao(e);
}
function Yf(e) {
  return Ao(e, (t2, n2) => t2 === "tgWebAppData" ? ml(n2) : JSON.stringify(n2));
}
function Mo(e) {
  const t2 = ll(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((n2, r, s) => {
      const o = parseInt(t2.slice(1 + s * 2, 1 + (s + 1) * 2), 16);
      return n2 + o * o * r;
    }, 0)
  ) < 120;
}
var [Tt, hl] = b(false);
var [ge, _l] = b({});
function T(e) {
  return h(() => ge()[e]);
}
var bl = T("accent_text_color");
var pt = T("bg_color");
var Ln = T("button_color");
var Po = T("button_text_color");
var xo = T("bottom_bar_bg_color");
var yl = T("destructive_text_color");
var gl = T("header_bg_color");
var vl = T("hint_color");
var wl = h(() => {
  const e = pt();
  return !e || Mo(e);
});
var El = T("link_color");
var Je = T("secondary_bg_color");
var $l = T("section_bg_color");
var Sl = T("section_header_text_color");
var Cl = T("section_separator_color");
var kl = T("subtitle_text_color");
var Al = T("text_color");
function me(e) {
  return h(() => Rn()[e]);
}
var je = Ce({
  hasShineEffect: false,
  isEnabled: true,
  isLoaderVisible: false,
  isVisible: false,
  text: "Continue"
});
var Rn = h(() => {
  const e = je();
  return {
    ...e,
    backgroundColor: e.backgroundColor || Ln() || "#2481cc",
    textColor: e.textColor || Po() || "#ffffff"
  };
});
var [en, To] = b(false);
var Ml = me("backgroundColor");
var Pl = me("hasShineEffect");
var xl = me("isEnabled");
var Tl = me("isLoaderVisible");
var Bl = me("isVisible");
var Ol = me("text");
var Il = me("textColor");
var jl = "web_app_setup_main_button";
var Bo = "main_button_pressed";
var dt = "mainButton";
var Hn = le(dt);
var ql = it(dt, To);
var Dl = Hn("mount", () => {
  if (!en()) {
    const e = z() && U(dt);
    e && je.set(e), en.set(true);
  }
});
var Nl = Hn(
  "onClick",
  (e) => k(Bo, e)
);
var Vl = Hn(
  "offClick",
  (e) => {
    B(Bo, e);
  }
);
var Ll = ql(
  "setParams",
  (e) => {
    je.set({ ...je(), ...jn(e) }), W(dt, je());
    const t2 = Rn();
    t2.text && _(jl, {
      color: t2.backgroundColor,
      has_shine_effect: t2.hasShineEffect,
      is_active: t2.isEnabled,
      is_progress_visible: t2.isLoaderVisible,
      is_visible: t2.isVisible,
      text: t2.text,
      text_color: t2.textColor
    });
  }
);
function Rl() {
  en.set(false);
}
var Zf = Object.freeze(Object.defineProperty({
  __proto__: null,
  backgroundColor: Ml,
  hasShineEffect: Pl,
  isEnabled: xl,
  isLoaderVisible: Tl,
  isMounted: To,
  isVisible: Bl,
  mount: Dl,
  offClick: Vl,
  onClick: Nl,
  setParams: Ll,
  state: Rn,
  text: Ol,
  textColor: Il,
  unmount: Rl
}, Symbol.toStringTag, { value: "Module" }));
function Fn(e, t2) {
  document.documentElement.style.setProperty(e, t2);
}
function Wn(e) {
  document.documentElement.style.removeProperty(e);
}
var Ne = "themeParams";
var Oo = "theme_changed";
var Hl = le(Ne);
var Io = ({ theme_params: e }) => {
  ge.set(e), W(Ne, e);
};
var [
  Fl,
  Wl,
  Ul,
  jo
] = Le(
  Ne,
  (e) => {
    const t2 = z() && U(Ne);
    return t2 ? x.resolve(t2) : S("web_app_request_theme", "theme_changed", e).then((n2) => n2.theme_params);
  },
  (e) => {
    k(Oo, Io), ge.set(e);
  }
);
var zl = it(Ne, jo[0]);
var Gl = zl(
  "bindCssVars",
  (e) => {
    if (Tt())
      throw new vn();
    e || (e = (r) => `--tg-theme-${Ni(r)}`);
    function t2(r) {
      Object.entries(ge()).forEach(([s, o]) => {
        o && r(s, o);
      });
    }
    function n2() {
      t2((r, s) => {
        Fn(e(r), s);
      });
    }
    return n2(), ge.sub(n2), Tt.set(true), () => {
      t2(Wn), ge.unsub(n2), Tt.set(false);
    };
  }
);
var qo = Hl("mount", Fl);
var [, Do, Ql] = Wl;
var [, Jl] = Ul;
var [Kl, Yl] = jo;
function Zl() {
  Ae(Do), B(Oo, Io), Kl.set(false);
}
function No(e) {
  return h(() => {
    const t2 = e();
    return we(t2) ? t2 : t2 === "bg_color" ? pt() : Je();
  });
}
var [Ke, Xl] = b("bg_color");
var Un = No(Ke);
var [Ye, ep] = b("bottom_bar_bg_color");
var zn = h(() => {
  const e = Ye();
  return we(e) ? e : e === "bottom_bar_bg_color" ? xo() || Je() : e === "secondary_bg_color" ? Je() : pt();
});
var [Ze, tp] = b("bg_color");
var Vo = No(Ze);
var [Bt, np] = b(false);
var rp = h(() => {
  const e = Un();
  return e ? Mo(e) : false;
});
var [Gn, sp] = b(true);
var Lo = h(() => ({
  backgroundColor: Ke(),
  bottomBarColor: Ye(),
  headerColor: Ze(),
  isActive: Gn()
}));
var tn = "web_app_set_background_color";
var nn = "web_app_set_bottom_bar_color";
var ze = "web_app_set_header_color";
var Ro = "visibility_changed";
var Ee = "miniApp";
var Qn = {
  any: [
    tn,
    nn,
    ze
  ]
};
var op = h(() => Qn.any.some((e) => de(e, se())));
var Ho = (e) => {
  Gn.set(e.is_visible), mt();
};
var [
  ap,
  ip,
  up,
  Fo
] = Le(
  Ee,
  (e) => qo(e).then(() => z() && U(Ee) || void 0),
  (e) => {
    zo.ifAvailable(e ? e.backgroundColor : "bg_color"), Go.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), Qo.ifAvailable(e ? e.headerColor : "bg_color"), Gn.set(e ? e.isActive : true), k(Ro, Ho);
  }
);
var Wo = le(Ee);
var cp = N(Ee, Qn);
var ft = ce(Ee, Fo[0], Qn);
var lp = ft(
  "bindCssVars",
  (e) => {
    if (Bt())
      throw new vn();
    const [t2, n2] = yn();
    function r(s, o) {
      function a() {
        Fn(s, o() || null);
      }
      a(), t2(o.sub(a), Wn.bind(null, s));
    }
    return e || (e = (s) => `--tg-${Cs(s)}`), r(e("bgColor"), Un), r(e("bottomBarColor"), zn), r(e("headerColor"), Vo), t2(() => {
      Bt.set(false);
    }), Bt.set(true), n2;
  }
);
var pp = Wo("close", (e) => {
  _("web_app_close", { return_back: e });
});
var dp = cp("mount", ap);
var [, Uo, fp] = ip;
var [, mp] = up;
var [hp, _p] = Fo;
var bp = Wo("ready", () => {
  _("web_app_ready");
});
function mt() {
  W(Ee, Lo());
}
var zo = ft(
  "setBackgroundColor",
  (e) => {
    e !== Ke() && (_(tn, { color: e }), Ke.set(e), mt());
  },
  tn
);
var Go = ft(
  "setBottomBarColor",
  (e) => {
    e !== Ye() && (_(nn, { color: e }), Ye.set(e), mt());
  },
  nn
);
var Qo = ft(
  "setHeaderColor",
  (e) => {
    e !== Ze() && (_(ze, we(e) ? { color: e } : { color_key: e }), Ze.set(e), mt());
  },
  ze,
  {
    rgb: [ze, "color", we]
  }
);
function yp() {
  Ae(Uo), B(Ro, Ho), hp.set(false);
}
var Xf = Object.freeze(Object.defineProperty({
  __proto__: null,
  backgroundColor: Xl,
  backgroundColorRGB: Un,
  bindCssVars: lp,
  bottomBarColor: ep,
  bottomBarColorRGB: zn,
  close: pp,
  headerColor: tp,
  headerColorRGB: Vo,
  isActive: sp,
  isCssVarsBound: np,
  isDark: rp,
  isMounted: _p,
  isMounting: fp,
  isSupported: op,
  mount: dp,
  mountError: mp,
  mountPromise: Uo,
  ready: bp,
  setBackgroundColor: zo,
  setBottomBarColor: Go,
  setHeaderColor: Qo,
  state: Lo,
  unmount: yp
}, Symbol.toStringTag, { value: "Module" }));
function gp(e) {
  const t2 = e.message.trim(), n2 = (e.title || "").trim(), r = e.buttons || [];
  if (n2.length > 64)
    throw new J(`Invalid title: ${n2}`);
  if (!t2 || t2.length > 256)
    throw new J(`Invalid message: ${t2}`);
  if (r.length > 3)
    throw new J(`Invalid buttons count: ${r.length}`);
  return {
    title: n2,
    message: t2,
    buttons: r.length ? r.map((s, o) => {
      const a = s.id || "";
      if (a.length > 64)
        throw new J(`Button with index ${o} has invalid id: ${a}`);
      if (!s.type || s.type === "default" || s.type === "destructive") {
        const i = s.text.trim();
        if (!i || i.length > 64)
          throw new J(`Button with index ${o} has invalid text: ${i}`);
        return { type: s.type, text: i, id: a };
      }
      return { type: s.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
var Jn = "web_app_open_popup";
var Jo = N("popup", Jn);
var vp = G(Jn);
var [Ko, Kn, Yo] = O(
  (e) => S(Jn, "popup_closed", {
    ...e,
    params: gp(e)
  }).then(({ button_id: t2 }) => t2 === void 0 ? null : t2),
  "A popup is already opened"
);
var wp = Jo("open", Ko);
var Ep = Kn[1];
var $p = Kn[2];
var Sp = Yo[1];
var Cp = Jo("show", Ko);
var [, kp, Ap] = Kn;
var [, Mp] = Yo;
var em = Object.freeze(Object.defineProperty({
  __proto__: null,
  isOpened: $p,
  isShown: Ap,
  isSupported: vp,
  open: wp,
  openError: Sp,
  openPromise: Ep,
  show: Cp,
  showError: Mp,
  showPromise: kp
}, Symbol.toStringTag, { value: "Module" }));
var Zo = "web_app_close_scan_qr_popup";
var Yn = "web_app_open_scan_qr_popup";
var Pp = "scan_qr_popup_closed";
var xp = "qr_text_received";
var Xo = N("qrScanner", Yn);
var Tp = Xo("close", () => {
  _(Zo), Ae(ea);
});
var Bp = G(Yn);
function Op(e) {
  e || (e = {});
  const { onCaptured: t2, text: n2, capture: r } = e, [, s] = yn(
    k(Pp, () => {
      o.resolve();
    }),
    k(xp, (a) => {
      t2 ? t2(a.data) : (!r || r(a.data)) && (o.resolve(a.data), _(Zo));
    })
  ), o = new du(e);
  return (e.postEvent || _)(Yn, { text: n2 }), x.resolve(o).catch(Ds).finally(s);
}
var [
  Ip,
  jp,
  qp
] = O(Op, "The QR Scanner is already opened");
var Dp = Xo("open", Ip);
var [, ea, Np] = jp;
var [, Vp] = qp;
var tm = Object.freeze(Object.defineProperty({
  __proto__: null,
  close: Tp,
  isOpened: Np,
  isSupported: Bp,
  open: Dp,
  openError: Vp,
  openPromise: ea
}, Symbol.toStringTag, { value: "Module" }));
function pe(e) {
  return h(() => Zn()[e]);
}
var qe = Ce({
  hasShineEffect: false,
  isEnabled: true,
  isLoaderVisible: false,
  isVisible: false,
  position: "left",
  text: "Cancel"
});
var Zn = h(() => {
  const e = qe();
  return {
    ...e,
    backgroundColor: e.backgroundColor || zn() || "#000000",
    textColor: e.textColor || Ln() || "#2481cc"
  };
});
var [rn, ta] = b(false);
var Lp = pe("backgroundColor");
var Rp = pe("hasShineEffect");
var Hp = pe("isEnabled");
var Fp = pe("isLoaderVisible");
var Wp = pe("isVisible");
var Up = pe("position");
var zp = pe("text");
var Gp = pe("textColor");
var ht = "web_app_setup_secondary_button";
var na = "secondary_button_pressed";
var _t = "secondaryButton";
var Xn = N(_t, ht);
var Qp = ce(_t, ta, ht);
var Jp = G(ht);
var Kp = Xn("mount", () => {
  if (!rn()) {
    const e = z() && U(_t);
    e && qe.set(e), rn.set(true);
  }
});
var Yp = Xn(
  "onClick",
  (e) => k(na, e)
);
var Zp = Xn(
  "offClick",
  (e) => {
    B(na, e);
  }
);
var Xp = Qp(
  "setParams",
  (e) => {
    qe.set({ ...qe(), ...jn(e) }), W(_t, qe());
    const t2 = Zn();
    t2.text && _(ht, {
      color: t2.backgroundColor,
      has_shine_effect: t2.hasShineEffect,
      is_active: t2.isEnabled,
      is_progress_visible: t2.isLoaderVisible,
      is_visible: t2.isVisible,
      position: t2.position,
      text: t2.text,
      text_color: t2.textColor
    });
  }
);
function ed() {
  rn.set(false);
}
var nm = Object.freeze(Object.defineProperty({
  __proto__: null,
  backgroundColor: Lp,
  hasShineEffect: Rp,
  isEnabled: Hp,
  isLoaderVisible: Fp,
  isMounted: ta,
  isSupported: Jp,
  isVisible: Wp,
  mount: Kp,
  offClick: Zp,
  onClick: Yp,
  position: Up,
  setParams: Xp,
  state: Zn,
  text: zp,
  textColor: Gp,
  unmount: ed
}, Symbol.toStringTag, { value: "Module" }));
var bt = "web_app_setup_settings_button";
var ra = "settings_button_pressed";
var yt = "settingsButton";
var [Nr, td] = b(false);
var [Xe, nd] = b(false);
var rd = G(bt);
var er = N(yt, bt);
var sa = ce(yt, Xe, bt);
var sd = sa("hide", () => {
  tr(false);
});
var od = er("mount", () => {
  Xe() || (tr(z() && U(yt) || false), Xe.set(true));
});
function tr(e) {
  e !== Nr() && (_(bt, { is_visible: e }), W(yt, e), Nr.set(e));
}
var ad = er(
  "onClick",
  (e) => k(ra, e)
);
var id = er(
  "offClick",
  (e) => {
    B(ra, e);
  }
);
var ud = sa("show", () => {
  tr(true);
});
function cd() {
  Xe.set(false);
}
var rm = Object.freeze(Object.defineProperty({
  __proto__: null,
  hide: sd,
  isMounted: nd,
  isSupported: rd,
  isVisible: td,
  mount: od,
  offClick: id,
  onClick: ad,
  show: ud,
  unmount: cd
}, Symbol.toStringTag, { value: "Module" }));
var gt = "web_app_setup_swipe_behavior";
var vt = "swipeBehavior";
var [Ve, ld] = b(false);
var pd = G(gt);
var [sn, dd] = b(true);
var fd = N(vt, gt);
var oa = ce(vt, Ve, gt);
var md = oa("disableVertical", () => {
  nr(false);
});
var hd = oa("enableVertical", () => {
  nr(true);
});
var _d = fd("mount", () => {
  Ve() || (nr(
    z() && U(vt) || false,
    true
  ), Ve.set(true));
});
function nr(e, t2) {
  (e !== sn() || t2) && (_(gt, { allow_vertical_swipe: e }), W(vt, e), sn.set(e));
}
function bd() {
  Ve.set(false);
}
var sm = Object.freeze(Object.defineProperty({
  __proto__: null,
  _isMounted: Ve,
  _isVerticalEnabled: sn,
  disableVertical: md,
  enableVertical: hd,
  isMounted: ld,
  isSupported: pd,
  isVerticalEnabled: dd,
  mount: _d,
  unmount: bd
}, Symbol.toStringTag, { value: "Module" }));
var om = Object.freeze(Object.defineProperty({
  __proto__: null,
  accentTextColor: bl,
  backgroundColor: pt,
  bindCssVars: Gl,
  bottomBarBgColor: xo,
  buttonColor: Ln,
  buttonTextColor: Po,
  destructiveTextColor: yl,
  headerBackgroundColor: gl,
  hintColor: vl,
  isCssVarsBound: hl,
  isDark: wl,
  isMounted: Yl,
  isMounting: Ql,
  linkColor: El,
  mount: qo,
  mountError: Jl,
  mountPromise: Do,
  secondaryBackgroundColor: Je,
  sectionBackgroundColor: $l,
  sectionHeaderTextColor: Sl,
  sectionSeparatorColor: Cl,
  state: _l,
  subtitleTextColor: kl,
  textColor: Al,
  unmount: Zl
}, Symbol.toStringTag, { value: "Module" }));
var he = "viewport";
var rr = "fullscreen_changed";
var sr = "safe_area_changed";
var or = "content_safe_area_changed";
var ar = "viewport_changed";
var aa = le(he);
var Vr = { left: 0, top: 0, bottom: 0, right: 0 };
function Ot(e) {
  return Math.max(e, 0);
}
var [It, ia] = b({
  contentSafeAreaInsets: Vr,
  height: 0,
  isExpanded: false,
  isFullscreen: false,
  safeAreaInsets: Vr,
  stableHeight: 0,
  width: 0
});
function _e(e) {
  return h(() => ia()[e]);
}
var ir = _e("height");
var ur = _e("stableHeight");
var ua = _e("width");
var yd = _e("isExpanded");
var gd = h(() => ir() === ur());
function Me(e) {
  const { height: t2, stableHeight: n2, width: r } = e;
  It.set({
    ...It(),
    ...jn({
      ...e,
      height: t2 ? Ot(t2) : void 0,
      width: r ? Ot(r) : void 0,
      stableHeight: n2 ? Ot(n2) : void 0
    })
  }), W(he, It());
}
function vd() {
  return U(he);
}
function wt(e) {
  return h(() => cr()[e]);
}
var cr = _e("contentSafeAreaInsets");
var ca = wt("bottom");
var la = wt("left");
var pa = wt("right");
var da = wt("top");
function Et(e) {
  return h(() => lr()[e]);
}
var lr = _e("safeAreaInsets");
var fa = Et("bottom");
var ma = Et("left");
var ha = Et("right");
var _a = Et("top");
var ba = "web_app_request_safe_area";
var ya = N(he, ba);
var Lr = ya(
  "requestContentSafeAreaInsets",
  (e) => S("web_app_request_content_safe_area", or, e)
);
function wd(e) {
  return S("web_app_request_viewport", ar, e);
}
var Rr = ya(
  "requestSafeAreaInsets",
  (e) => S(ba, sr, e)
);
var ga = (e) => {
  const { height: t2 } = e;
  Me({
    isExpanded: e.is_expanded,
    height: t2,
    width: e.width,
    stableHeight: e.is_state_stable ? t2 : void 0
  });
};
var va = (e) => {
  Me({ isFullscreen: e.is_fullscreen });
};
var wa = (e) => {
  Me({ safeAreaInsets: e });
};
var Ea = (e) => {
  Me({ contentSafeAreaInsets: e });
};
var [
  Ed,
  $d,
  Sd,
  Cd
] = Le(
  he,
  (e) => {
    const t2 = z() && vd();
    return t2 ? x.resolve(t2) : x.fn(async (n2) => {
      const r = await x.all([
        Rr.isAvailable() ? Rr(n2) : lr(),
        Lr.isAvailable() ? Lr(n2) : cr()
      ]), s = gn(), o = {
        contentSafeAreaInsets: r[1],
        isFullscreen: !!s.tgWebAppFullscreen,
        safeAreaInsets: r[0]
      };
      if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(s.tgWebAppPlatform)) {
        const a = window;
        return {
          ...o,
          height: a.innerHeight,
          isExpanded: true,
          stableHeight: a.innerHeight,
          width: a.innerWidth
        };
      }
      return wd(n2).then((a) => ({
        ...o,
        height: a.height,
        isExpanded: a.is_expanded,
        stableHeight: a.is_state_stable ? a.height : 0,
        width: a.width
      }));
    }, e);
  },
  (e) => {
    k(ar, ga), k(rr, va), k(sr, wa), k(or, Ea), Me(e);
  }
);
var kd = aa("mount", Ed);
var [, $a, Ad] = $d;
var [, Md] = Sd;
var [pr, Pd] = Cd;
function xd() {
  Ae($a), B(ar, ga), B(rr, va), B(sr, wa), B(or, Ea), pr.set(false);
}
var Td = it(he, pr);
var [jt, Bd] = b(false);
var Od = Td(
  "bindCssVars",
  (e) => {
    if (jt())
      throw new vn();
    e || (e = (n2) => `--tg-viewport-${Cs(n2)}`);
    const t2 = [
      ["height", ir],
      ["stableHeight", ur],
      ["width", ua],
      ["safeAreaInsetTop", _a],
      ["safeAreaInsetBottom", fa],
      ["safeAreaInsetLeft", ma],
      ["safeAreaInsetRight", ha],
      ["contentSafeAreaInsetTop", da],
      ["contentSafeAreaInsetBottom", ca],
      ["contentSafeAreaInsetLeft", la],
      ["contentSafeAreaInsetRight", pa]
    ].reduce((n2, [r, s]) => {
      const o = e(r);
      if (o) {
        const a = () => {
          Fn(o, `${s()}px`);
        };
        n2.push([a, s.sub(a), o]);
      }
      return n2;
    }, []);
    return t2.forEach((n2) => {
      n2[0]();
    }), jt.set(true), () => {
      t2.forEach((n2) => {
        n2[1](), Wn(n2[2]);
      }), jt.set(false);
    };
  }
);
var Id = aa("expand", () => {
  _("web_app_expand");
});
var Sa = "web_app_request_fullscreen";
var jd = ce(he, pr, Sa);
var Ca = _e("isFullscreen");
var [
  qd,
  Dd
] = b();
var [
  Nd,
  Vd
] = b();
function ka(e, t2) {
  return jd(
    e,
    O(
      (n2) => S(
        t2 ? Sa : "web_app_exit_fullscreen",
        [rr, "fullscreen_failed"],
        n2
      ).then((r) => {
        if ("error" in r && r.error !== "ALREADY_FULLSCREEN")
          throw new Qi(r.error);
        const s = "is_fullscreen" in r ? r.is_fullscreen : true;
        s !== Ca() && Me({ isFullscreen: s });
      }),
      "Fullscreen mode change is already being requested",
      {
        promise: qd,
        error: Nd
      }
    )[0]
  );
}
var Ld = ka("requestFullscreen", true);
var Rd = ka("exitFullscreen");
var am = Object.freeze(Object.defineProperty({
  __proto__: null,
  bindCssVars: Od,
  changeFullscreenError: Vd,
  changeFullscreenPromise: Dd,
  contentSafeAreaInsetBottom: ca,
  contentSafeAreaInsetLeft: la,
  contentSafeAreaInsetRight: pa,
  contentSafeAreaInsetTop: da,
  contentSafeAreaInsets: cr,
  exitFullscreen: Rd,
  expand: Id,
  height: ir,
  isCssVarsBound: Bd,
  isExpanded: yd,
  isFullscreen: Ca,
  isMounted: Pd,
  isMounting: Ad,
  isStable: gd,
  mount: kd,
  mountError: Md,
  mountPromise: $a,
  requestFullscreen: Ld,
  safeAreaInsetBottom: fa,
  safeAreaInsetLeft: ma,
  safeAreaInsetRight: ha,
  safeAreaInsetTop: _a,
  safeAreaInsets: lr,
  stableHeight: ur,
  state: ia,
  unmount: xd,
  width: ua
}, Symbol.toStringTag, { value: "Module" }));
var Aa = "web_app_request_emoji_status_access";
var [
  Hd,
  Fd,
  Wd
] = O((e) => S(Aa, "emoji_status_access_requested", e).then((t2) => t2.status), "Emoji status access request is already in progress");
var im = C(
  "requestEmojiStatusAccess",
  Hd,
  { isSupported: Aa }
);
var [, um, cm] = Fd;
var [, lm] = Wd;
var Ma = "web_app_set_emoji_status";
var [
  Ud,
  zd,
  Gd
] = O(
  (e, t2) => S(Ma, ["emoji_status_set", "emoji_status_failed"], {
    params: {
      custom_emoji_id: e,
      duration: (t2 || {}).duration
    },
    ...t2
  }).then((n2) => {
    if (n2 && "error" in n2)
      throw new Gi(n2.error);
  }),
  "Emoji status set request is currently in progress"
);
var pm = C("setEmojiStatus", Ud, {
  isSupported: Ma
});
var [, dm, fm] = zd;
var [, mm] = Gd;
var Qd = { isSupported: "web_app_add_to_home_screen" };
var Pa = "home_screen_failed";
var hm = C(
  "onAddToHomeScreenFailed",
  (e, t2) => k(Pa, e, t2),
  { isSupported: "web_app_add_to_home_screen" }
);
var _m = C(
  "offAddToHomeScreenFailed",
  (e) => {
    B(Pa, e);
  },
  Qd
);
var xa = { isSupported: "web_app_add_to_home_screen" };
var Ta = "home_screen_added";
var bm = C(
  "onAddedToHomeScreen",
  (e, t2) => k(Ta, e, t2),
  xa
);
var ym = C(
  "offAddedToHomeScreen",
  (e) => {
    B(Ta, e);
  },
  xa
);
var Hr = "web_app_add_to_home_screen";
var gm = C(
  "addToHomeScreen",
  () => {
    _(Hr);
  },
  { isSupported: Hr }
);
var Ba = "web_app_check_home_screen";
var [
  Jd,
  Kd,
  Yd
] = O((e) => S(Ba, "home_screen_checked", e).then((t2) => t2.status || "unknown"), "Check home screen status request is currently in progress");
var vm = C("checkHomeScreenStatus", Jd, {
  isSupported: Ba
});
var [, wm, Em] = Kd;
var [, $m] = Yd;
var Zd = le();
var Sm = Zd(
  "openLink",
  (e, t2) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (n2) {
        throw new J(`"${e.toString()}" is invalid URL`, n2);
      }
    t2 || (t2 = {}), _("web_app_open_link", {
      url: e.toString(),
      try_browser: t2.tryBrowser,
      try_instant_view: t2.tryInstantView
    });
  }
);
var Fr = "web_app_open_tg_link";
var Xd = le();
var ef = Xd(
  "openTelegramLink",
  (e) => {
    const t2 = e.toString();
    if (!t2.match(/^https:\/\/t.me\/.+/))
      throw new J(`"${t2}" is invalid URL`);
    if (!de(Fr, se())) {
      window.location.href = t2;
      return;
    }
    e = new URL(e), _(Fr, { path_full: e.pathname + e.search });
  }
);
var tf = le();
var Cm = tf(
  "shareURL",
  (e, t2) => {
    ef(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t2 || "" }).toString().replace(/\+/g, "%20")
    );
  }
);
function nf(e, t2) {
  return new x({ abortSignal: t2, timeout: e }).catch(() => {
  });
}
var Oa = "web_app_request_phone";
var [
  rf,
  sf,
  of
] = O((e) => S(Oa, "phone_requested", e).then((t2) => t2.status), "Phone access request is currently in progress");
var af = C("requestPhoneAccess", rf, {
  isSupported: Oa
});
var [, km, Am] = sf;
var [, Mm] = of;
async function Wr(e) {
  const t2 = await ke("getRequestedContact", {}, {
    ...e,
    timeout: (e || {}).timeout || 5e3
  });
  return ct(
    Ue(
      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.
      to([H(), Zs(URLSearchParams)]),
      So(
        Zt({
          contact: Ue(
            H(),
            $o(),
            Zt({
              user_id: xn(),
              phone_number: H(),
              first_name: H(),
              last_name: Xs(H())
            })
          ),
          auth_date: Ue(
            H(),
            Mn((n2) => new Date(Number(n2) * 1e3)),
            Pn()
          ),
          hash: H()
        })
      )
    ),
    t2
  );
}
var [
  uf,
  cf,
  lf
] = O(
  (e) => new x(async (t2, n2, r) => {
    try {
      return t2(await Wr(r));
    } catch (a) {
      if (a instanceof Yt)
        throw a;
    }
    if (await af(r) !== "sent")
      throw new Bs("User denied access");
    let o = 50;
    for (; !r.isAborted(); ) {
      try {
        return t2(await Wr(r));
      } catch (a) {
        if (a instanceof Yt)
          throw a;
      }
      await nf(o), o += 50;
    }
  }, e),
  "Contact is already being requested"
);
var Pm = C("requestContact", uf, {
  isSupported: "web_app_request_phone"
});
var [, xm, Tm] = cf;
var [, Bm] = lf;
var Ia = "web_app_request_write_access";
var [
  pf,
  df,
  ff
] = O(
  (e) => S(Ia, "write_access_requested", e).then((t2) => t2.status),
  "Write access request is currently in progress"
);
var Om = C("requestWriteAccess", pf, {
  isSupported: Ia
});
var [, Im, jm] = df;
var [, qm] = ff;
function mf(e) {
  const t2 = document.createElement("textarea");
  t2.value = e, t2.style.top = "0", t2.style.left = "0", t2.style.position = "fixed", document.body.appendChild(t2), t2.focus(), t2.select();
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(t2);
  }
}
async function Dm(e) {
  try {
    const { clipboard: t2 } = navigator;
    if (t2)
      return await t2.writeText(e);
  } catch {
  }
  mf(e);
}
var Ur = "web_app_request_file_download";
var Nm = C(
  "downloadFile",
  (e, t2, n2) => S(
    Ur,
    "file_download_requested",
    { ...n2, params: { url: e, file_name: t2 } }
  ).then((r) => {
    if (r.status !== "downloading")
      throw new Bs("User denied the action");
  }),
  { isSupported: Ur }
);
var Vm = C(
  "getCurrentTime",
  (e) => ke("getCurrentTime", {}, e).then((t2) => ct(
    Ue(xn(), Js(), Mn((n2) => new Date(n2 * 1e3)), Pn()),
    t2
  )),
  { isSupported: "web_app_invoke_custom_method" }
);
var zr = "web_app_read_text_from_clipboard";
var Lm = C(
  "readTextFromClipboard",
  (e) => {
    const t2 = xs();
    return S(zr, "clipboard_text_received", {
      ...e,
      params: { req_id: t2 },
      capture: Ss(t2)
    }).then(({ data: n2 = null }) => n2);
  },
  { isSupported: zr }
);
var Gr = "web_app_data_send";
var Rm = C(
  "sendData",
  (e) => {
    const { size: t2 } = new Blob([e]);
    if (!t2 || t2 > 4096)
      throw new J(t2 ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    _(Gr, { data: e });
  },
  { isSupported: Gr }
);
var Qr = "web_app_send_prepared_message";
var Hm = C(
  "shareMessage",
  (e, t2) => S(Qr, ["prepared_message_failed", "prepared_message_sent"], {
    ...t2,
    params: { id: e }
  }).then((n2) => {
    if (n2 && "error" in n2)
      throw new Ji(n2.error);
  }),
  { isSupported: Qr }
);
var Jr = "web_app_share_to_story";
var Fm = C(
  "shareStory",
  (e, t2) => {
    t2 || (t2 = {}), _(Jr, {
      text: t2.text,
      media_url: e,
      widget_link: t2.widgetLink
    });
  },
  { isSupported: Jr }
);
var hf = "web_app_switch_inline_query";
var Wm = C(
  "switchInlineQuery",
  (e, t2) => {
    _(hf, {
      query: e,
      chat_types: t2 || []
    });
  },
  {
    isSupported() {
      return gn().tgWebAppBotInline ? void 0 : "The application must be launched in the inline mode";
    }
  }
);
function Um(e) {
  try {
    return [true, e()];
  } catch (t2) {
    return [false, t2];
  }
}
function zm(e) {
  Wi(e);
  const [t2, n2] = yn(
    k("reload_iframe", () => {
      zt(false, "Received a request to reload the page"), _("iframe_will_reload"), window.location.reload();
    })
  ), { acceptCustomStyles: r = true } = e || {};
  if (r) {
    const s = document.createElement("style");
    s.id = "telegram-custom-styles", document.head.appendChild(s), t2(
      k("set_custom_style", (o) => {
        s.innerHTML = o;
      }),
      () => {
        document.head.removeChild(s);
      }
    );
  }
  return _("iframe_ready", { reload_supported: true }), zt(false, "The package was initialized"), n2;
}

// node_modules/@telegram-apps/sdk-react/dist/index.js
function n(r, e) {
  return (0, import_react.useSyncExternalStore)(
    (o) => r.sub(o),
    r,
    e || r
  );
}
export {
  un as AbortablePromise,
  Bs as AccessDeniedError,
  vn as CSSVarsBoundError,
  Ha as CancelledError,
  zi as ConcurrentCallError,
  Qi as FullscreenFailedError,
  Pe as FunctionUnavailableError,
  J as InvalidArgumentsError,
  Tf as InvalidEnvError,
  Ai as InvalidLaunchParamsError,
  Pi as InvokeCustomMethodError,
  ki as LaunchParamsRetrieveError,
  yf as ManualPromise,
  Si as MethodParameterUnsupportedError,
  $i as MethodUnsupportedError,
  Ts as NotAvailableError,
  Gi as SetEmojiStatusError,
  Ji as ShareMessageError,
  Fa as TimeoutError,
  Mi as UnknownEnvError,
  gm as addToHomeScreen,
  Mu as authenticateBiometry,
  Lf as backButton,
  lp as bindMiniAppCssVars,
  Gl as bindThemeParamsCssVars,
  Od as bindViewportCssVars,
  Hf as biometry,
  xu as biometryAuthError,
  Fs as biometryAuthPromise,
  Eu as biometryMountError,
  fu as biometryState,
  Vd as changeFullscreenError,
  Dd as changeFullscreenPromise,
  vm as checkHomeScreenStatus,
  $m as checkHomeScreenStatusError,
  wm as checkHomeScreenStatusPromise,
  pp as closeMiniApp,
  Tp as closeQrScanner,
  Ff as closingBehavior,
  Wf as cloudStorage,
  Wi as configure,
  Dm as copyTextToClipboard,
  qi as createPostEvent,
  xs as createRequestId,
  ro as deleteCloudStorageItem,
  Hu as disableClosingConfirmation,
  md as disableVerticalSwipes,
  Nm as downloadFile,
  yr as emitEvent,
  Fu as enableClosingConfirmation,
  hd as enableVerticalSwipes,
  Rd as exitFullscreen,
  Id as expandViewport,
  Xu as getCloudStorageItem,
  so as getCloudStorageKeys,
  Vm as getCurrentTime,
  Uf as hapticFeedback,
  rc as hapticFeedbackImpactOccurred,
  sc as hapticFeedbackNotificationOccurred,
  oc as hapticFeedbackSelectionChanged,
  Xi as hideBackButton,
  sd as hideSettingsButton,
  Ds as ignoreCanceled,
  zm as init,
  zf as initData,
  ao as initDataAuthDate,
  io as initDataCanSendAfter,
  ic as initDataCanSendAfterDate,
  uc as initDataChat,
  lc as initDataChatInstance,
  cc as initDataChatType,
  pc as initDataHash,
  dc as initDataQueryId,
  mc as initDataRaw,
  hc as initDataReceiver,
  bc as initDataStartParam,
  ac as initDataState,
  yc as initDataUser,
  Gf as invoice,
  ke as invokeCustomMethod,
  Df as isAccessDeniedError,
  Pu as isAuthenticatingBiometry,
  Yi as isBackButtonMounted,
  Zi as isBackButtonSupported,
  Ki as isBackButtonVisible,
  mu as isBiometryAvailable,
  Su as isBiometryMounted,
  wu as isBiometryMounting,
  _u as isBiometrySupported,
  Pf as isCSSVarsBoundError,
  _f as isCancelledError,
  Em as isCheckingHomeScreenStatus,
  Us as isClosingBehaviorMounted,
  Lu as isClosingConfirmationEnabled,
  Yu as isCloudStorageSupported,
  Mo as isColorDark,
  jf as isConcurrentCallError,
  Ca as isFullscreen,
  Nf as isFullscreenFailedError,
  Of as isFunctionNotAvailableError,
  nc as isHapticFeedbackSupported,
  If as isInvalidArguments,
  Bf as isInvalidEnvError,
  $f as isInvalidLaunchParamsError,
  Ac as isInvoiceOpened,
  vc as isInvoiceSupported,
  Cf as isInvokeCustomMethodError,
  Ef as isLaunchParamsRetrieveError,
  Tc as isLocationManagerAccessGranted,
  Bc as isLocationManagerAccessRequested,
  xc as isLocationManagerAvailable,
  Fc as isLocationManagerMounted,
  Lc as isLocationManagerMounting,
  Pc as isLocationManagerSupported,
  xl as isMainButtonEnabled,
  Tl as isMainButtonLoaderVisible,
  To as isMainButtonMounted,
  Bl as isMainButtonVisible,
  wf as isMethodMethodParameterUnsupportedError,
  vf as isMethodUnsupportedError,
  sp as isMiniAppActive,
  np as isMiniAppCssVarsBound,
  rp as isMiniAppDark,
  _p as isMiniAppMounted,
  fp as isMiniAppMounting,
  op as isMiniAppSupported,
  xf as isNotAvailableError,
  $p as isPopupOpened,
  Ap as isPopupShown,
  vp as isPopupSupported,
  Np as isQrScannerOpened,
  Bp as isQrScannerSupported,
  we as isRGB,
  cl as isRGBShort,
  qu as isRequestingBiometryAccess,
  Tm as isRequestingContact,
  cm as isRequestingEmojiStatusAccess,
  Qc as isRequestingLocation,
  Am as isRequestingPhoneAccess,
  jm as isRequestingWriteAccess,
  kr as isSSR,
  Hp as isSecondaryButtonEnabled,
  Fp as isSecondaryButtonLoaderVisible,
  ta as isSecondaryButtonMounted,
  Jp as isSecondaryButtonSupported,
  Wp as isSecondaryButtonVisible,
  qf as isSetEmojiStatusError,
  fm as isSettingEmojiStatus,
  nd as isSettingsButtonMounted,
  rd as isSettingsButtonSupported,
  td as isSettingsButtonVisible,
  Vf as isShareMessageError,
  ld as isSwipeBehaviorMounted,
  pd as isSwipeBehaviorSupported,
  $r as isTMA,
  hl as isThemeParamsCssVarsBound,
  wl as isThemeParamsDark,
  Yl as isThemeParamsMounted,
  Ql as isThemeParamsMounting,
  bf as isTimeoutError,
  Sf as isUnknownEnvError,
  dd as isVerticalSwipesEnabled,
  Bd as isViewportCssVarsBound,
  yd as isViewportExpanded,
  Pd as isViewportMounted,
  Ad as isViewportMounting,
  gd as isViewportStable,
  Qf as locationManager,
  Rc as locationManagerMountError,
  Vc as locationManagerMountPromise,
  Zf as mainButton,
  Ml as mainButtonBackgroundColor,
  Pl as mainButtonHasShineEffect,
  Rn as mainButtonState,
  Ol as mainButtonText,
  Il as mainButtonTextColor,
  Xf as miniApp,
  Xl as miniAppBackgroundColor,
  Un as miniAppBackgroundColorRGB,
  ep as miniAppBottomBarColor,
  zn as miniAppBottomBarColorRGB,
  tp as miniAppHeaderColor,
  Vo as miniAppHeaderColorRGB,
  mp as miniAppMountError,
  Uo as miniAppMountPromise,
  bp as miniAppReady,
  Lo as miniAppState,
  kf as mockTelegramEnv,
  eu as mountBackButton,
  vu as mountBiometry,
  Hs as mountBiometryPromise,
  Wu as mountClosingBehavior,
  Nc as mountLocationManager,
  Dl as mountMainButton,
  dp as mountMiniApp,
  Kp as mountSecondaryButton,
  od as mountSettingsButton,
  _d as mountSwipeBehavior,
  qo as mountThemeParams,
  kd as mountViewport,
  B as off,
  _m as offAddToHomeScreenFailed,
  ym as offAddedToHomeScreen,
  nu as offBackButtonClick,
  Vl as offMainButtonClick,
  Zp as offSecondaryButtonClick,
  id as offSettingsButtonClick,
  k as on,
  hm as onAddToHomeScreenFailed,
  bm as onAddedToHomeScreen,
  tu as onBackButtonClick,
  Nl as onMainButtonClick,
  Yp as onSecondaryButtonClick,
  ad as onSettingsButtonClick,
  Tu as openBiometrySettings,
  Cc as openInvoice,
  Mc as openInvoiceError,
  kc as openInvoicePromise,
  Sm as openLink,
  Kc as openLocationManagerSettings,
  wp as openPopup,
  Sp as openPopupError,
  Ep as openPopupPromise,
  Dp as openQrScanner,
  Vp as openQrScannerError,
  ea as openQrScannerPromise,
  ef as openTelegramLink,
  Jf as parseInitDataQuery,
  Kf as parseLaunchParamsQuery,
  em as popup,
  _ as postEvent,
  tm as qrScanner,
  Lm as readTextFromClipboard,
  S as request,
  hu as requestBiometry,
  ju as requestBiometryAccess,
  Du as requestBiometryAccessError,
  Ws as requestBiometryAccessPromise,
  Pm as requestContact,
  Bm as requestContactError,
  xm as requestContactPromise,
  Lr as requestContentSafeAreaInsets,
  im as requestEmojiStatusAccess,
  lm as requestEmojiStatusAccessError,
  um as requestEmojiStatusAccessPromise,
  Ld as requestFullscreen,
  Gc as requestLocation,
  Jc as requestLocationError,
  lo as requestLocationPromise,
  af as requestPhoneAccess,
  Mm as requestPhoneAccessError,
  km as requestPhoneAccessPromise,
  Rr as requestSafeAreaInsets,
  wd as requestViewport,
  Om as requestWriteAccess,
  qm as requestWriteAccessError,
  Im as requestWriteAccessPromise,
  _c as restoreInitData,
  bn as retrieveLaunchParams,
  Ii as retrieveRawInitData,
  $s as retrieveRawLaunchParams,
  Um as safeCall,
  nm as secondaryButton,
  Lp as secondaryButtonBackgroundColor,
  Rp as secondaryButtonHasShineEffect,
  Up as secondaryButtonPosition,
  Zn as secondaryButtonState,
  zp as secondaryButtonText,
  Gp as secondaryButtonTextColor,
  Rm as sendData,
  ml as serializeInitDataQuery,
  Yf as serializeLaunchParamsQuery,
  Ao as serializeToQuery,
  ec as setCloudStorageItem,
  Mf as setDebug,
  pm as setEmojiStatus,
  mm as setEmojiStatusError,
  dm as setEmojiStatusPromise,
  Ll as setMainButtonParams,
  zo as setMiniAppBackgroundColor,
  Go as setMiniAppBottomBarColor,
  Qo as setMiniAppHeaderColor,
  Xp as setSecondaryButtonParams,
  rm as settingsButton,
  Hm as shareMessage,
  Fm as shareStory,
  Cm as shareURL,
  ru as showBackButton,
  Cp as showPopup,
  Mp as showPopupError,
  kp as showPopupPromise,
  ud as showSettingsButton,
  de as supports,
  sm as swipeBehavior,
  Wm as switchInlineQuery,
  Oi as targetOrigin,
  om as themeParams,
  bl as themeParamsAccentTextColor,
  pt as themeParamsBackgroundColor,
  xo as themeParamsBottomBarBgColor,
  Ln as themeParamsButtonColor,
  Po as themeParamsButtonTextColor,
  yl as themeParamsDestructiveTextColor,
  gl as themeParamsHeaderBackgroundColor,
  vl as themeParamsHintColor,
  El as themeParamsLinkColor,
  Jl as themeParamsMountError,
  Do as themeParamsMountPromise,
  Je as themeParamsSecondaryBackgroundColor,
  $l as themeParamsSectionBackgroundColor,
  Sl as themeParamsSectionHeaderTextColor,
  Cl as themeParamsSectionSeparatorColor,
  _l as themeParamsState,
  kl as themeParamsSubtitleTextColor,
  Al as themeParamsTextColor,
  ll as toRGB,
  So as transformQueryUsing,
  su as unmountBackButton,
  Nu as unmountBiometry,
  Uu as unmountClosingBehavior,
  Yc as unmountLocationManager,
  Rl as unmountMainButton,
  yp as unmountMiniApp,
  ed as unmountSecondaryButton,
  cd as unmountSettingsButton,
  bd as unmountSwipeBehavior,
  Zl as unmountThemeParams,
  xd as unmountViewport,
  Vu as updateBiometryToken,
  n as useSignal,
  am as viewport,
  ca as viewportContentSafeAreaInsetBottom,
  la as viewportContentSafeAreaInsetLeft,
  pa as viewportContentSafeAreaInsetRight,
  da as viewportContentSafeAreaInsetTop,
  cr as viewportContentSafeAreaInsets,
  ir as viewportHeight,
  Md as viewportMountError,
  $a as viewportMountPromise,
  fa as viewportSafeAreaInsetBottom,
  ma as viewportSafeAreaInsetLeft,
  ha as viewportSafeAreaInsetRight,
  _a as viewportSafeAreaInsetTop,
  lr as viewportSafeAreaInsets,
  ur as viewportStableHeight,
  ia as viewportState,
  ua as viewportWidth,
  C as wrapSafe
};
//# sourceMappingURL=@telegram-apps_sdk-react.js.map
