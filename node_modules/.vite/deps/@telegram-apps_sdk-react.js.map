{
  "version": 3,
  "sources": ["../../@telegram-apps/bridge/dist/index.js", "../../@telegram-apps/toolkit/dist/index.js", "../../@telegram-apps/navigation/dist/index.js", "../../@telegram-apps/signals/dist/index.js", "../../@telegram-apps/sdk/src/signals-registry.ts", "../../@telegram-apps/sdk/src/debug.ts", "../../@telegram-apps/sdk/src/globals.ts", "../../@telegram-apps/sdk/src/scopes/createIsSupported.ts", "../../node_modules/.pnpm/error-kid@0.0.4/node_modules/error-kid/dist/index.js", "../../@telegram-apps/sdk/src/errors.ts", "../../@telegram-apps/sdk/src/utils/isSSR.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/wrapSafe.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapSafe.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapComplete.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapSupported.ts", "../../@telegram-apps/sdk/src/scopes/components/back-button/back-button.ts", "../../node_modules/.pnpm/better-promises@0.4.0/node_modules/better-promises/dist/index.js", "../../@telegram-apps/sdk/src/scopes/defineNonConcurrentFn.ts", "../../@telegram-apps/sdk/src/scopes/defineMountFn.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/requestBiometry.ts", "../../@telegram-apps/sdk/src/utils/ignoreCanceled.ts", "../../@telegram-apps/sdk/src/scopes/signalCancel.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/methods.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapMounted.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapBasic.ts", "../../@telegram-apps/sdk/src/scopes/components/closing-behavior/closing-behavior.ts", "../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js", "../../@telegram-apps/sdk/src/scopes/components/cloud-storage/cloud-storage.ts", "../../@telegram-apps/sdk/src/scopes/components/haptic-feedback/haptic-feedback.ts", "../../@telegram-apps/sdk/src/scopes/components/init-data/init-data.ts", "../../@telegram-apps/sdk/src/scopes/components/invoice/invoice.ts", "../../@telegram-apps/sdk/src/scopes/components/location-manager/location-manager.ts", "../../@telegram-apps/sdk/src/utils/removeUndefined.ts", "../../@telegram-apps/transformers/dist/index.js", "../../@telegram-apps/sdk/src/utils/isColorDark.ts", "../../@telegram-apps/sdk/src/scopes/components/theme-params/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/main-button/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/main-button/methods.ts", "../../@telegram-apps/sdk/src/utils/css-vars.ts", "../../@telegram-apps/sdk/src/scopes/components/theme-params/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/mini-app/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/mini-app/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/popup/prepareParams.ts", "../../@telegram-apps/sdk/src/scopes/components/popup/popup.ts", "../../@telegram-apps/sdk/src/scopes/components/qr-scanner/qr-scanner.ts", "../../@telegram-apps/sdk/src/scopes/components/secondary-button/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/secondary-button/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/settings-button/settings-button.ts", "../../@telegram-apps/sdk/src/scopes/components/swipe-behavior/swipe-behavior.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/const.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/wrappers.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/static.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/mounting.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/css-vars.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/expand.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/fullscreen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/emoji-status/setEmojiStatus.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/add-to-home-screen-failed.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/added-to-home-screen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/addToHomeScreen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/checkHomeScreenStatus.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/openLink.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/openTelegramLink.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/shareURL.ts", "../../@telegram-apps/sdk/src/utils/sleep.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestPhoneAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestContact.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestWriteAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/copyTextToClipboard.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/downloadFile.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/getCurrentTime.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/readTextFromClipboard.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/sendData.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/shareMessage.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/shareStory.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/switchInlineQuery.ts", "../../@telegram-apps/sdk/src/utils/safeCall.ts", "../../@telegram-apps/sdk/src/init.ts", "../../@telegram-apps/sdk-react/src/useSignal.ts"],
  "sourcesContent": ["var E;\n// @__NO_SIDE_EFFECTS__\nfunction Pe(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? (E == null ? void 0 : E.lang),\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? (E == null ? void 0 : E.abortEarly),\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? (E == null ? void 0 : E.abortPipeEarly)\n  };\n}\nvar N;\n// @__NO_SIDE_EFFECTS__\nfunction it(t) {\n  return N == null ? void 0 : N.get(t);\n}\nvar U;\n// @__NO_SIDE_EFFECTS__\nfunction at(t) {\n  return U == null ? void 0 : U.get(t);\n}\nvar O;\n// @__NO_SIDE_EFFECTS__\nfunction ot(t, e) {\n  var n;\n  return (n = O == null ? void 0 : O.get(t)) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction ut(t) {\n  var n, r;\n  const e = typeof t;\n  return e === \"string\" ? `\"${t}\"` : e === \"number\" || e === \"bigint\" || e === \"boolean\" ? `${t}` : e === \"object\" || e === \"function\" ? (t && ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null ? void 0 : r.name)) ?? \"null\" : e;\n}\nfunction A(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ ut(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ ot(t.reference, o.lang) ?? (c ? /* @__PURE__ */ at(o.lang) : null) ?? r.message ?? /* @__PURE__ */ it(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Pe());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ct(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\nvar pt = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction ee(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Se() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: Se,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: G,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(t) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: te,\n    expects: \"Function\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"function\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: g,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      var a;\n      const s = n.value;\n      if (s && typeof s == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in s || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ ee(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (a = n.issues) == null || a.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (A(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ ct(s, i) && !(i in this.entries) && (n.value[i] = s[i]);\n      } else\n        A(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: T,\n    expects: `(${t.expects} | null | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return (n.value === null || n.value === void 0) && (this.default !== void 0 && (n.value = /* @__PURE__ */ ee(this, n, r)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: B,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction F(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: F,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ ee(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: k,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction je() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: je,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction K(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Pe(n));\n  if (r.issues)\n    throw new pt(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ae(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction qe(t) {\n  return /* @__PURE__ */ W(\n    /* @__PURE__ */ g({ TelegramWebviewProxy: /* @__PURE__ */ g({ postEvent: /* @__PURE__ */ te() }) }),\n    t\n  );\n}\nfunction Me() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar lt = Object.defineProperty, ft = (t, e, n) => e in t ? lt(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Y = (t, e, n) => ft(t, typeof e != \"symbol\" ? e + \"\" : e, n);\nfunction dt(t) {\n  return (e) => e instanceof t;\n}\nfunction Te(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, dt(n)];\n}\nconst [_t, ln] = Te(\"CancelledError\", \"Promise was canceled\"), [yt, fn] = Te(\n  \"TimeoutError\",\n  (t, e) => [`Timeout reached: ${t}ms`, { cause: e }]\n), Ie = Symbol(\"Resolved\");\nfunction de(t) {\n  return Array.isArray(t) && t[0] === Ie;\n}\nfunction bt(t) {\n  return [Ie, t];\n}\nfunction _e(t, e) {\n  return t.reject = e.reject, t.abort = e.abort, t;\n}\nlet ne = class H extends Promise {\n  constructor(e, n) {\n    let r, s;\n    super((a, i) => {\n      let u, o;\n      typeof e == \"function\" ? (u = e, o = n) : o = e;\n      const c = [], p = (f) => (...j) => {\n        const L = f(...j);\n        return c.forEach((st) => st()), L;\n      }, l = new AbortController(), { signal: y } = l;\n      s = (f) => {\n        !y.aborted && l.abort(f);\n      };\n      const b = () => y.reason, P = (f) => {\n        const j = () => {\n          f(b());\n        };\n        y.addEventListener(\"abort\", j, !0);\n        const L = () => {\n          y.removeEventListener(\"abort\", j, !0);\n        };\n        return c.push(L), L;\n      }, rt = p((f) => {\n        a(f), s(bt(f));\n      });\n      r = p((f) => {\n        i(f), s(f);\n      }), o || (o = {});\n      const { abortSignal: S, rejectOnAbort: ce = !0 } = o;\n      if (S)\n        if (S.aborted) {\n          const { reason: f } = S;\n          if (ce)\n            return r(f);\n          s(f);\n        } else {\n          const f = () => {\n            s(S.reason);\n          };\n          S.addEventListener(\"abort\", f), c.push(() => {\n            S.removeEventListener(\"abort\", f);\n          });\n        }\n      ce && P(i);\n      const { timeout: C } = o;\n      if (C) {\n        const f = setTimeout(() => {\n          s(new yt(C));\n        }, C);\n        c.push(() => {\n          clearTimeout(f);\n        });\n      }\n      const pe = () => y.aborted, le = () => de(b()), fe = () => {\n        const f = b();\n        return de(f) ? f[1] : void 0;\n      };\n      try {\n        const f = u && u(rt, r, {\n          abortReason: b,\n          abortSignal: y,\n          isAborted: pe,\n          isResolved: le,\n          onAborted: P,\n          onResolved: (j) => P(() => {\n            le() && j(fe());\n          }),\n          resolved: fe,\n          throwIfAborted() {\n            if (pe())\n              throw b();\n          }\n        });\n        f instanceof Promise && f.catch(r);\n      } catch (f) {\n        r(f);\n      }\n    }), Y(this, \"abort\"), Y(this, \"reject\"), this.abort = s, this.reject = r;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new H(async (r, s, a) => {\n      try {\n        r(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new H((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new _t());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return _e(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return _e(super.then(e, n), this);\n  }\n};\nfunction ye(t, e) {\n  return t.resolve = e.resolve, t;\n}\nlet dn = class Q extends ne {\n  constructor(e, n) {\n    let r, s;\n    typeof e == \"function\" ? (r = e, s = n) : s = e;\n    let a;\n    super((i, u, o) => {\n      a = i, r && r(i, u, o);\n    }, s), Y(this, \"resolve\"), this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new Q((r, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(r, s);\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new Q((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return ye(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return ye(super.then(e, n), this);\n  }\n};\nfunction ht(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction mt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[ht(n)] = r, e), {});\n}\nfunction Z(t) {\n  const e = mt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(Z) : Z(r));\n  }\n  return e;\n}\nfunction Le(t) {\n  return `tapps/${t}`;\n}\nfunction Re(t, e) {\n  sessionStorage.setItem(Le(t), JSON.stringify(e));\n}\nfunction vt(t) {\n  const e = sessionStorage.getItem(Le(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction gt(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((n) => {\n        n();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction wt(t, e) {\n  e || (e = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: s\n  } = e, a = s === void 0 ? !0 : s, i = typeof a == \"boolean\" ? () => a : a;\n  function u(o, c, ...p) {\n    if (c || i()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[o](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,\n        `${l};background-color: lightblue;color:black`,\n        \"\",\n        `${l};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...p\n      );\n    }\n  }\n  return [u.bind(void 0, \"log\"), u.bind(void 0, \"error\")];\n}\n// @__NO_SIDE_EFFECTS__\nfunction We(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? void 0,\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? void 0,\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? void 0\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Et(t, e) {\n  var n;\n  return (n = void 0) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction kt(t) {\n  var e, n;\n  const r = typeof t;\n  return r === \"string\" ? `\"${t}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${t}` : r === \"object\" || r === \"function\" ? (t && ((n = (e = Object.getPrototypeOf(t)) == null ? void 0 : e.constructor) == null ? void 0 : n.name)) ?? \"null\" : r;\n}\nfunction m(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ kt(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ Et(t.reference, o.lang) ?? (c ? (o.lang, void 0) : null) ?? r.message ?? (o.lang, void 0);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ We());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction De(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction xt(t, e) {\n  const n = [...new Set(t)];\n  return n.length > 1 ? `(${n.join(` ${e} `)})` : n[0] ?? \"never\";\n}\nvar $t = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction Ce(t, e) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: Ce,\n    async: !1,\n    expects: null,\n    requirement: t,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && m(this, \"input\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ne(t) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: Ne,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: t,\n    \"~run\"(e, n) {\n      return e.typed && !this.requirement(e.value) && m(this, \"integer\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: x,\n    async: !1,\n    operation: t,\n    \"~run\"(e) {\n      return e.value = this.operation(e.value), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ue(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction Pt(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction I(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: I,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Oe(t) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: Oe,\n    expects: \"Date\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      return e.value instanceof Date ? isNaN(e.value) ? m(this, \"type\", e, n, {\n        received: '\"Invalid Date\"'\n      }) : e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Je(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: Je,\n    expects: t.name,\n    async: !1,\n    class: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof this.class ? n.typed = !0 : m(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(t) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: re,\n    expects: \"unknown\",\n    async: !1,\n    getter: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      return this.getter(e.value)[\"~run\"](e, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: q,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(n, r) {\n      var s;\n      const a = n.value;\n      if (a && typeof a == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in a || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in a ? (\n              // @ts-expect-error\n              a[i]\n            ) : /* @__PURE__ */ Ue(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: a,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (s = n.issues) == null || s.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (m(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: a,\n                key: i,\n                // @ts-expect-error\n                value: a[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in a)\n            /* @__PURE__ */ De(a, i) && !(i in this.entries) && (n.value[i] = a[i]);\n      } else\n        m(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: D,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: _,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Ue(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ze(t, e, n) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: ze,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(r, s) {\n      var a, i;\n      const u = r.value;\n      if (u && typeof u == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ De(u, o)) {\n            const c = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of p.issues)\n                b.path = [y], (a = r.issues) == null || a.push(b);\n              if (r.issues || (r.issues = p.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            const l = this.value[\"~run\"](\n              { value: c },\n              s\n            );\n            if (l.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of l.issues)\n                b.path ? b.path.unshift(y) : b.path = [y], (i = r.issues) == null || i.push(b);\n              if (r.issues || (r.issues = l.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !l.typed) && (r.typed = !1), p.typed && (r.value[p.value] = l.value);\n          }\n      } else\n        m(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: d,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction be(t) {\n  let e;\n  if (t)\n    for (const n of t)\n      e ? e.push(...n.issues) : e = n.issues;\n  return e;\n}\n// @__NO_SIDE_EFFECTS__\nfunction se(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: se,\n    expects: /* @__PURE__ */ xt(\n      t.map((n) => n.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(n, r) {\n      let s, a, i;\n      for (const u of this.options) {\n        const o = u[\"~run\"]({ value: n.value }, r);\n        if (o.typed)\n          if (o.issues)\n            a ? a.push(o) : a = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (a) {\n        if (a.length === 1)\n          return a[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ be(a)\n        }), n.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ be(i)\n        });\n      }\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ge() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: Ge,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction Be(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ We(n));\n  if (r.issues)\n    throw new $t(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ v(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction St(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction jt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[St(n)] = r, e), {});\n}\nfunction X(t) {\n  const e = jt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(X) : X(r));\n  }\n  return e;\n}\nfunction ie(t) {\n  return /* @__PURE__ */ x((e) => t ? X(e) : e);\n}\nfunction Fe(t) {\n  return (e) => /* @__PURE__ */ $(\n    t,\n    ie(e)\n  );\n}\nfunction At(t) {\n  return (e, n) => Be(\n    /* @__PURE__ */ $(t, ie(n)),\n    e\n  );\n}\nfunction ae() {\n  return /* @__PURE__ */ x(JSON.parse);\n}\nfunction oe(t) {\n  const e = Fe(t);\n  return (n) => /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    ae(),\n    e(n)\n  );\n}\nfunction qt(t) {\n  return /* @__PURE__ */ x((e) => {\n    const n = {};\n    return new URLSearchParams(e).forEach((r, s) => {\n      const a = n[s];\n      Array.isArray(a) ? a.push(r) : a === void 0 ? n[s] = r : n[s] = [a, r];\n    }), Be(t, n);\n  });\n}\nfunction Ke(t) {\n  return (e) => /* @__PURE__ */ $(\n    /* @__PURE__ */ se([/* @__PURE__ */ d(), /* @__PURE__ */ Je(URLSearchParams)]),\n    qt(t),\n    ie(e)\n  );\n}\nconst he = /* @__PURE__ */ _(/* @__PURE__ */ re(() => Rt())), Mt = /* @__PURE__ */ q({\n  id: /* @__PURE__ */ D(),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  type: /* @__PURE__ */ d(),\n  title: /* @__PURE__ */ d(),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), Tt = /* @__PURE__ */ q({\n  added_to_attachment_menu: /* @__PURE__ */ _(/* @__PURE__ */ I()),\n  allows_write_to_pm: /* @__PURE__ */ _(/* @__PURE__ */ I()),\n  first_name: /* @__PURE__ */ d(),\n  id: /* @__PURE__ */ D(),\n  is_bot: /* @__PURE__ */ _(/* @__PURE__ */ I()),\n  is_premium: /* @__PURE__ */ _(/* @__PURE__ */ I()),\n  last_name: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  language_code: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), It = /* @__PURE__ */ q({\n  auth_date: /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ x((t) => new Date(Number(t) * 1e3)),\n    /* @__PURE__ */ Oe()\n  ),\n  can_send_after: /* @__PURE__ */ _(/* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x(Number), /* @__PURE__ */ Ne())),\n  chat: /* @__PURE__ */ _(/* @__PURE__ */ re(() => Lt())),\n  chat_type: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  chat_instance: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  hash: /* @__PURE__ */ d(),\n  query_id: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  receiver: he,\n  start_param: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  signature: /* @__PURE__ */ d(),\n  user: he\n}), Lt = oe(Mt), Rt = oe(Tt), Wt = Ke(It);\nfunction Dt(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nconst Ye = Fe(\n  /* @__PURE__ */ ze(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ $(\n      /* @__PURE__ */ se([/* @__PURE__ */ d(), /* @__PURE__ */ D()]),\n      /* @__PURE__ */ x((t) => typeof t == \"number\" ? `#${(t & 16777215).toString(16).padStart(6, \"0\")}` : t),\n      /* @__PURE__ */ Ce(Dt)\n    )\n  )\n), J = /* @__PURE__ */ _(\n  /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x((t) => t === \"1\"))\n), me = oe(Ye()), Ct = /* @__PURE__ */ q({\n  tgWebAppBotInline: J,\n  tgWebAppData: /* @__PURE__ */ _(Wt()),\n  tgWebAppDefaultColors: /* @__PURE__ */ _(me()),\n  tgWebAppFullscreen: J,\n  tgWebAppPlatform: /* @__PURE__ */ d(),\n  tgWebAppShowSettings: J,\n  tgWebAppStartParam: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  tgWebAppThemeParams: me(),\n  tgWebAppVersion: /* @__PURE__ */ d()\n}), He = Ke(Ct), Nt = At(He()), Qe = /* @__PURE__ */ q({\n  eventType: /* @__PURE__ */ d(),\n  eventData: /* @__PURE__ */ _(/* @__PURE__ */ Ge())\n});\nfunction Ze(t, e) {\n  return e || (e = (n, r) => JSON.stringify(r)), new URLSearchParams(\n    Object.entries(t).reduce((n, [r, s]) => (Array.isArray(s) ? n.push(...s.map((a) => [r, String(a)])) : s != null && n.push([\n      r,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : e(r, s)\n    ]), n), [])\n  ).toString();\n}\nfunction Ut(t) {\n  return Ze(t);\n}\nfunction Ot(t) {\n  return Ze(t, (e, n) => e === \"tgWebAppData\" ? Ut(n) : JSON.stringify(n));\n}\nfunction Xe(t) {\n  try {\n    return /* @__PURE__ */ Pt(He(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction Jt(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, n) {\n    var r = t.get(e);\n    r ? r.push(n) : t.set(e, [n]);\n  }, off: function(e, n) {\n    var r = t.get(e);\n    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, n) {\n    var r = t.get(e);\n    r && r.slice().map(function(s) {\n      s(n);\n    }), (r = t.get(\"*\")) && r.slice().map(function(s) {\n      s(e, n);\n    });\n  } };\n}\nfunction zt(t, e) {\n  const n = Jt(), r = /* @__PURE__ */ new Map(), s = (a, i, u) => {\n    u || (u = !1);\n    const o = r.get(a) || /* @__PURE__ */ new Map();\n    r.set(a, o);\n    const c = o.get(i) || [];\n    o.set(i, c);\n    const p = c.findIndex((l) => l[1] === u);\n    p >= 0 && (n.off(a, c[p][0]), c.splice(p, 1), !c.length && o.delete(i), o.size || (r.delete(a), !r.size && e()));\n  };\n  return [\n    function(i, u, o) {\n      !r.size && t();\n      function c() {\n        s(i, u, o);\n      }\n      function p(...b) {\n        o && c(), i === \"*\" ? u(b) : u(...b);\n      }\n      n.on(i, p);\n      const l = r.get(i) || /* @__PURE__ */ new Map();\n      r.set(i, l);\n      const y = l.get(u) || [];\n      return l.set(u, y), y.push([p, o || !1]), c;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    n.emit,\n    function() {\n      const i = n.all.size;\n      n.all.clear(), r.clear(), i && e();\n    }\n  ];\n}\nfunction ve(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet R = !1;\nconst [ue, Gt] = /* @__PURE__ */ wt(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return R;\n  }\n}), ge = (t) => {\n  ue(!1, \"Event received:\", t);\n};\nfunction Bt(t) {\n  t !== R && (R = t, R ? Ve(\"*\", ge) : Kt(\"*\", ge));\n}\nconst Ft = {\n  clipboard_text_received: /* @__PURE__ */ g({\n    req_id: /* @__PURE__ */ k(),\n    data: /* @__PURE__ */ T(/* @__PURE__ */ k())\n  }),\n  custom_method_invoked: /* @__PURE__ */ g({\n    req_id: /* @__PURE__ */ k(),\n    result: /* @__PURE__ */ F(/* @__PURE__ */ je()),\n    error: /* @__PURE__ */ F(/* @__PURE__ */ k())\n  }),\n  popup_closed: /* @__PURE__ */ T(\n    /* @__PURE__ */ g({ button_id: /* @__PURE__ */ T(/* @__PURE__ */ k(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: /* @__PURE__ */ g({\n    height: /* @__PURE__ */ B(),\n    width: /* @__PURE__ */ T(/* @__PURE__ */ B(), () => window.innerWidth),\n    is_state_stable: /* @__PURE__ */ G(),\n    is_expanded: /* @__PURE__ */ G()\n  }),\n  theme_changed: /* @__PURE__ */ g({\n    theme_params: Ye()\n  })\n};\nfunction we(t) {\n  if (t.source !== window.parent)\n    return;\n  let e;\n  try {\n    e = K(/* @__PURE__ */ Ae(/* @__PURE__ */ k(), ae(), Qe), t.data);\n  } catch {\n    return;\n  }\n  const { eventType: n, eventData: r } = e, s = Ft[n];\n  try {\n    const a = s ? K(s, r) : r;\n    Yt(n, a);\n  } catch (a) {\n    Gt(\n      !0,\n      [\n        `An error occurred processing the \"${n}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      e,\n      a\n    );\n  }\n}\nconst [\n  Ve,\n  Kt,\n  Yt,\n  Ht\n] = zt(\n  () => {\n    const t = window, e = { receiveEvent: ve };\n    t.TelegramGameProxy_receiveEvent = ve, t.TelegramGameProxy = e, t.Telegram = { WebView: e }, window.addEventListener(\"message\", we);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n      delete window[t];\n    }), window.removeEventListener(\"message\", we);\n  }\n);\nfunction Qt(t) {\n  return (e) => e instanceof t;\n}\nfunction M(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, Qt(n)];\n}\nconst [\n  Zt,\n  _n\n] = M(\n  \"MethodUnsupportedError\",\n  (t, e) => [\n    `Method \"${t}\" is unsupported in Mini Apps version ${e}`\n  ]\n), [\n  Xt,\n  yn\n] = M(\n  \"MethodParameterUnsupportedError\",\n  (t, e, n) => [\n    `Parameter \"${e}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n  ]\n), Vt = [\n  \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n  \"ðŸ“– Refer to docs for more information:\",\n  \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\"\n].join(`\n`), [\n  en,\n  bn\n] = M(\"LaunchParamsRetrieveError\", Vt), [\n  tn,\n  hn\n] = M(\"InvalidLaunchParamsError\", (t) => [\n  `Invalid value for launch params: ${t}`\n]), [nn, mn] = M(\"UnknownEnvError\"), [\n  rn,\n  vn\n] = M(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n);\nfunction sn(t, e) {\n  e();\n}\n// @__NO_SIDE_EFFECTS__\nfunction an(t, e) {\n  e || (e = {});\n  const n = e.equals || Object.is;\n  let r = [], s = t;\n  const a = (c) => {\n    if (!n(s, c)) {\n      const p = s;\n      s = c, sn(o, () => {\n        [...r].forEach(([l, y]) => {\n          l(c, p), y && u(l, !0);\n        });\n      });\n    }\n  };\n  function i(c) {\n    const p = typeof c != \"object\" ? { once: c } : c;\n    return {\n      once: p.once || !1,\n      signal: p.signal || !1\n    };\n  }\n  const u = (c, p) => {\n    const l = i(p), y = r.findIndex(([b, P]) => b === c && P.once === l.once && P.signal === l.signal);\n    y >= 0 && r.splice(y, 1);\n  }, o = Object.assign(\n    function() {\n      return on(o), s;\n    },\n    {\n      destroy() {\n        r = [];\n      },\n      set: a,\n      reset() {\n        a(t);\n      },\n      sub(c, p) {\n        return r.push([c, i(p)]), () => u(c, p);\n      },\n      unsub: u,\n      unsubAll() {\n        r = r.filter((c) => c[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst z = [];\nfunction on(t) {\n  z.length && z[z.length - 1].add(t);\n}\nconst V = /* @__PURE__ */ an(\"https://web.telegram.org\");\nfunction et(t, e) {\n  ue(!1, \"Posting event:\", e ? { eventType: t, eventData: e } : { eventType: t });\n  const n = window, r = JSON.stringify({ eventType: t, eventData: e });\n  if (Me())\n    return n.parent.postMessage(r, V());\n  if (qe(n)) {\n    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));\n    return;\n  }\n  if (/* @__PURE__ */ W(/* @__PURE__ */ g({ external: /* @__PURE__ */ g({ notify: /* @__PURE__ */ te() }) }), n)) {\n    n.external.notify(r);\n    return;\n  }\n  throw new nn();\n}\nfunction tt(t, e, n) {\n  n || (n = {});\n  const { capture: r } = n, [s, a] = gt();\n  return new ne((i) => {\n    (Array.isArray(e) ? e : [e]).forEach((u) => {\n      s(\n        Ve(u, (o) => {\n          (!r || (Array.isArray(e) ? r({\n            event: u,\n            payload: o\n          }) : r(o))) && i(o);\n        })\n      );\n    }), (n.postEvent || et)(t, n.params);\n  }, n).finally(a);\n}\nconst Ee = \"launchParams\";\nfunction ke(t) {\n  return t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction nt() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    () => ke(window.location.href),\n    // Then, try using the lower level API - window.performance.\n    () => {\n      const e = performance.getEntriesByType(\"navigation\")[0];\n      return e && ke(e.name);\n    },\n    () => vt(Ee)\n  ]) {\n    const e = t();\n    if (e && Xe(e))\n      return Re(Ee, e), e;\n  }\n  throw new en();\n}\nfunction un(t) {\n  const e = Nt(nt());\n  return t ? Z(e) : e;\n}\nfunction gn(t, e) {\n  if (!t)\n    try {\n      return un(), !0;\n    } catch {\n      return !1;\n    }\n  return ne.fn(async (n) => {\n    if (qe(window))\n      return !0;\n    try {\n      return await tt(\"web_app_request_theme\", \"theme_changed\", n), !0;\n    } catch {\n      return !1;\n    }\n  }, e || { timeout: 100 });\n}\nfunction wn({ launchParams: t, onEvent: e } = {}) {\n  if (t) {\n    const s = typeof t == \"string\" || t instanceof URLSearchParams ? t.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ot({ ...t, tgWebAppData: void 0 }) + (t.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(t.tgWebAppData.toString())}` : \"\")\n    );\n    if (!Xe(s))\n      throw new tn(s);\n    Re(\"launchParams\", s);\n  }\n  if (Me()) {\n    const s = /* @__PURE__ */ Ae(\n      /* @__PURE__ */ k(),\n      ae(),\n      Qe\n    ), a = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (...i) => {\n      const [u] = i, o = () => {\n        a(...i);\n      };\n      if (/* @__PURE__ */ W(s, u) && e) {\n        const c = K(s, u);\n        e([c.eventType, c.eventData], o);\n      } else\n        o();\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, { postEvent: r } = n;\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(s, a) {\n      const i = () => {\n        r && r(s, a);\n      };\n      e ? e([s, a ? JSON.parse(a) : void 0], i) : i();\n    }\n  }, ue(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction En() {\n  return new URLSearchParams(nt()).get(\"tgWebAppData\") || void 0;\n}\nfunction cn(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction xe(t) {\n  return t.split(\".\").map(Number);\n}\nfunction pn(t, e) {\n  const n = xe(t), r = xe(e), s = Math.max(n.length, r.length);\n  for (let a = 0; a < s; a += 1) {\n    const i = n[a] || 0, u = r[a] || 0;\n    if (i !== u)\n      return i > u ? 1 : -1;\n  }\n  return 0;\n}\nfunction h(t, e) {\n  return pn(t, e) <= 0;\n}\nfunction $e(t, e, n) {\n  if (typeof n == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return h(\"6.4\", n);\n      if (e === \"try_browser\")\n        return h(\"7.6\", n);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return h(\"6.9\", n);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return h(\"7.6\", n);\n    if (t === \"web_app_setup_main_button\" && e === \"has_shine_effect\")\n      return h(\"7.10\", n);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return h(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return h(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return h(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return h(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return h(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return h(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return h(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return h(\"7.7\", e);\n    case \"web_app_share_to_story\":\n      return h(\"7.8\", e);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return h(\"7.10\", e);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return h(\"8.0\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction kn(t, e) {\n  e || (e = \"strict\");\n  const n = typeof e == \"function\" ? e : (r) => {\n    const { method: s, version: a } = r, i = \"param\" in r ? new Xt(s, r.param, a) : new Zt(s, a);\n    if (e === \"strict\")\n      throw i;\n    return console.warn(i.message);\n  };\n  return (r, s) => $e(r, t) ? r === \"web_app_set_header_color\" && /* @__PURE__ */ W(/* @__PURE__ */ g({ color: /* @__PURE__ */ Se() }), s) && !$e(r, \"color\", t) ? n({ version: t, method: r, param: \"color\" }) : et(r, s) : n({ version: t, method: r });\n}\nfunction xn(t, e, n, r) {\n  return tt(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...r || {},\n    params: { method: t, params: e, req_id: n },\n    capture: cn(n)\n  }).then(({ result: s, error: a }) => {\n    if (a)\n      throw new rn(a);\n    return s;\n  });\n}\nfunction $n() {\n  Ht(), Bt(!1), V.unsubAll(), V.reset();\n}\nexport {\n  ne as AbortablePromise,\n  _t as CancelledError,\n  tn as InvalidLaunchParamsError,\n  rn as InvokeCustomMethodError,\n  en as LaunchParamsRetrieveError,\n  dn as ManualPromise,\n  Xt as MethodParameterUnsupportedError,\n  Zt as MethodUnsupportedError,\n  yt as TimeoutError,\n  nn as UnknownEnvError,\n  cn as captureSameReq,\n  pn as compareVersions,\n  kn as createPostEvent,\n  ve as emitEvent,\n  qe as hasWebviewProxy,\n  xn as invokeCustomMethod,\n  ln as isCancelledError,\n  Me as isIframe,\n  hn as isInvalidLaunchParamsError,\n  vn as isInvokeCustomMethodError,\n  bn as isLaunchParamsRetrieveError,\n  yn as isMethodMethodParameterUnsupportedError,\n  _n as isMethodUnsupportedError,\n  gn as isTMA,\n  fn as isTimeoutError,\n  mn as isUnknownEnvError,\n  wn as mockTelegramEnv,\n  Kt as off,\n  Ht as offAll,\n  Ve as on,\n  et as postEvent,\n  tt as request,\n  $n as resetPackageState,\n  un as retrieveLaunchParams,\n  En as retrieveRawInitData,\n  nt as retrieveRawLaunchParams,\n  Bt as setDebug,\n  $e as supports,\n  V as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n", "function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n", "function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n", "let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n", "import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}", "import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}", "import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_launchParams, launchParams] =\n  createSignalsTuple<PackageLaunchParams>({\n    tgWebAppPlatform: 'unknown',\n    tgWebAppVersion: '0.0',\n  });\n\nexport const version = createComputed(() => launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n", "import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}", "var f = Object.defineProperty;\nvar u = (t, r, n) => r in t ? f(t, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[r] = n;\nvar c = (t, r, n) => u(t, typeof r != \"symbol\" ? r + \"\" : r, n);\nfunction i(t) {\n  return (r) => r instanceof t;\n}\nfunction d(t, r) {\n  r || (r = []);\n  class n extends Error {\n    constructor(...e) {\n      const o = typeof r == \"function\" ? r(...e) : typeof r == \"string\" ? [r] : r || [];\n      super(...o), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, i(n)];\n}\nfunction m(t, r, n) {\n  class s extends d(t, n)[0] {\n    constructor(...a) {\n      super(...a);\n      c(this, \"data\");\n      this.data = r(...a);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: t }), [s, i(s)];\n}\nexport {\n  d as errorClass,\n  m as errorClassWithData,\n  i as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n", "import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);", "/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n", "import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n", "import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n", "import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n", "import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}", "import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "var V = Object.defineProperty;\nvar Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;\nvar y = (n, r, e) => Y(n, typeof r != \"symbol\" ? r + \"\" : r, e);\nfunction $(n) {\n  return (r) => r instanceof n;\n}\nfunction B(n, r) {\n  r || (r = []);\n  class e extends Error {\n    constructor(...o) {\n      const s = typeof r == \"function\" ? r(...o) : typeof r == \"string\" ? [r] : r || [];\n      super(...s), this.name = n;\n    }\n  }\n  return Object.defineProperty(e, \"name\", { value: n }), [e, $(e)];\n}\nconst [k, H] = B(\"CancelledError\", \"Promise was canceled\"), [q, J] = B(\n  \"TimeoutError\",\n  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]\n), D = Symbol(\"Resolved\");\nfunction S(n) {\n  return Array.isArray(n) && n[0] === D;\n}\nfunction z(n) {\n  return [D, n];\n}\nfunction x(n, r) {\n  return n.reject = r.reject, n.abort = r.abort, n;\n}\nclass w extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let d, u;\n      typeof e == \"function\" ? (d = e, u = c) : u = e;\n      const b = [], j = (t) => (...h) => {\n        const p = t(...h);\n        return b.forEach((P) => P()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (t) => {\n        !l.aborted && g.abort(t);\n      };\n      const v = () => l.reason, E = (t) => {\n        const h = () => {\n          t(v());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return b.push(p), p;\n      }, F = j((t) => {\n        a(t), s(z(t));\n      });\n      o = j((t) => {\n        i(t), s(t);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: t } = f;\n          if (A)\n            return o(t);\n          s(t);\n        } else {\n          const t = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", t), b.push(() => {\n            f.removeEventListener(\"abort\", t);\n          });\n        }\n      A && E(i);\n      const { timeout: m } = u;\n      if (m) {\n        const t = setTimeout(() => {\n          s(new q(m));\n        }, m);\n        b.push(() => {\n          clearTimeout(t);\n        });\n      }\n      const L = () => l.aborted, T = () => S(v()), C = () => {\n        const t = v();\n        return S(t) ? t[1] : void 0;\n      };\n      try {\n        const t = d && d(F, o, {\n          abortReason: v,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: T,\n          onAborted: E,\n          onResolved: (h) => E(() => {\n            T() && h(C());\n          }),\n          resolved: C,\n          throwIfAborted() {\n            if (L())\n              throw v();\n          }\n        });\n        t instanceof Promise && t.catch(o);\n      } catch (t) {\n        o(t);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new w(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new w((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new k());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(n, r) {\n  return n.resolve = r.resolve, n;\n}\nclass R extends w {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, d, u) => {\n      a = i, o && o(i, d, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  w as AbortablePromise,\n  k as CancelledError,\n  R as ManualPromise,\n  q as TimeoutError,\n  H as isCancelledError,\n  S as isPromiseResolveResult,\n  J as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n", "import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}", "import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n", "import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n", "import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n", "import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}", "import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}", "import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n", "import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}", "import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n", "import { AbortablePromise } from 'better-promises';\nimport { array, parse, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      const response = {\n        // Fulfill the response with probably missing keys.\n        ...keys.reduce<Record<string, string>>((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {}),\n        ...parse(record(string(), string()), data),\n      };\n\n      return typeof keyOrKeys === 'string' ? response[keyOrKeys] : response;\n    })\n    : AbortablePromise.resolve(Array.isArray(keyOrKeys) ? {} : '');\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));", "import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n", "import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');", "import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}", "import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}", "var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ U(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ W(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ N(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ d((n) => e ? w(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ v(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ v(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ d((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ v(\n    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ E(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ E(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ z()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: Q,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: Q\n}), ye = C(le), he = C(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ V(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v(\n      /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ E()]),\n      /* @__PURE__ */ d((e) => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e),\n      /* @__PURE__ */ L(H)\n    )\n  )\n), x = /* @__PURE__ */ c(\n  /* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d((e) => e === \"1\"))\n), G = C(be()), de = /* @__PURE__ */ k({\n  tgWebAppBotInline: x,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(G()),\n  tgWebAppFullscreen: x,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: x,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: G(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(de), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  de as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  C as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  ve as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n", "import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n", "import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n", "import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_request_theme', 'theme_changed', options).then(d => d.theme_params);\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}", "import type { Computed } from '@telegram-apps/signals';\nimport { isRGB } from '@telegram-apps/transformers';\nimport type { BackgroundColor, BottomBarColor } from '@telegram-apps/bridge';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  backgroundColor as themeBgColor,\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  bottomBarBgColor as themeBottomBarBgColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { HeaderColor, State } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nfunction rgbBasedOn(signal: Computed<'bg_color' | 'secondary_bg_color' | RGB>) {\n  return createComputed<RGB | undefined>(() => {\n    const color = signal();\n\n    return isRGB(color) ? color : color === 'bg_color'\n      ? themeBgColor()\n      : themeSecondaryBgColor();\n  });\n}\n\n/**\n * The Mini App background color.\n */\nexport const [_backgroundColor, backgroundColor] =\n  createSignalsTuple<BackgroundColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] =\n  createSignalsTuple<BottomBarColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    : color === 'bottom_bar_bg_color'\n      // Following the logic from the Telegram SDK.\n      // I removed \"|| '#ffffff'\" because this seems too strange to me. This is just not right.\n      ? themeBottomBarBgColor() || themeSecondaryBgColor()\n      : color === 'secondary_bg_color'\n        ? themeSecondaryBgColor()\n        : themeBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<HeaderColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n", "import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type BottomBarColor,\n  type BackgroundColor,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { version, postEvent } from '@/globals.js';\nimport { mount as mountThemeParams } from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { GetCssVarNameFn, HeaderColor, State } from './types.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport { RGB } from '@telegram-apps/types';\n\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: BackgroundColor): void => {\n    if (color !== _backgroundColor()) {\n      postEvent(SET_BG_COLOR_METHOD, { color });\n      _backgroundColor.set(color);\n      saveState();\n    }\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: BottomBarColor) => {\n    if (color !== _bottomBarColor()) {\n      postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color });\n      _bottomBarColor.set(color);\n      saveState();\n    }\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: HeaderColor): void => {\n    if (color !== _headerColor()) {\n      postEvent(SET_HEADER_COLOR_METHOD, isRGB(color) ? { color } : { color_key: color });\n      _headerColor.set(color);\n      saveState();\n    }\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  _isMounted.set(false);\n}\n", "import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}", "import type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { ShowOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [fn, tPromise, tShowError] = defineNonConcurrentFn(\n  (options: ShowOptions): AbortablePromise<string | null> => {\n    return request(OPEN_METHOD, 'popup_closed', {\n      ...options,\n      params: prepareParams(options),\n    }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n  },\n  'A popup is already opened',\n);\n\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `show` instead.\n */\nexport const open = wrapSupported('open', fn);\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showPromise` instead.\n */\nconst openPromise = tPromise[1];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `isShown` instead.\n */\nconst isOpened = tPromise[2];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showError` instead.\n */\nconst openError = tShowError[1];\n\nexport { openPromise, isOpened, openError };\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const show = wrapSupported('show', fn);\nexport const [, showPromise, isShown] = tPromise;\nexport const [, showError] = tShowError;\n", "import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;", "import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}", "import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';", "import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n", "import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion", "import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);", "import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n", "import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n", "import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n", "import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');", "import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;", "import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;", "import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);", "import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);", "import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;", "import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);", "import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);", "import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n", "import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n", "import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;", "import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n  };\n  auth_date: Date;\n  hash: string;\n}\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContact> {\n  const data = await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  });\n\n  return parse(\n    pipe(\n      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n      union([string(), instance(URLSearchParams)]),\n      transformQueryUsing(\n        looseObject({\n          contact: pipe(\n            string(),\n            jsonParse(),\n            looseObject({\n              user_id: number(),\n              phone_number: string(),\n              first_name: string(),\n              last_name: optional(string()),\n            }),\n          ),\n          auth_date: pipe(\n            string(),\n            transform(input => new Date(Number(input) * 1000)),\n            date(),\n          ),\n          hash: string(),\n        }),\n      ),\n    ),\n    data,\n  );\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return new AbortablePromise<RequestedContact>(async (res, _, context) => {\n      // First of all, let's try to get the requested contact. Probably, we already requested it\n      // before.\n      try {\n        return res(await getRequestedContact(context));\n      } catch (e) {\n        if (e instanceof ValiError) {\n          throw e;\n        }\n      }\n\n      // Then, request access to the user's phone.\n      const status = await requestPhoneAccess(context);\n      if (status !== 'sent') {\n        throw new AccessDeniedError('User denied access');\n      }\n\n      // Time to wait before executing the next request.\n      let sleepTime = 50;\n\n      // We are trying to retrieve the requested contact until the deadline was reached.\n      while (!context.isAborted()) {\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Sleep for some time.\n        await sleep(sleepTime);\n\n        // Increase the sleep time not to kill the backend service.\n        sleepTime += 50;\n      }\n    }, options);\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe('requestContact', fn, {\n  isSupported: 'web_app_request_phone',\n});\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;", "import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n", "function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}", "import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);", "import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);", "import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_data_send';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent(METHOD_NAME, { data });\n  },\n  { isSupported: METHOD_NAME },\n);\n", "import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);", "import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { launchParams, postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n  {\n    isSupported() {\n      return launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    }\n  }\n);\n", "export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n", "import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}", "import { useSyncExternalStore } from 'react';\n\n/**\n * Returns the underlying signal value updating it each time the signal value changes.\n * @param signal - a signal.\n * @param getServerSnapshot - an optional function returning the signal value snapshot. It is used only during SSR\n * to provide an initial value of the signal. When not set, defaults to the signal itself.\n */\nexport function useSignal<T>(\n  signal: {\n    (): T;\n    sub(fn: VoidFunction): VoidFunction;\n  },\n  getServerSnapshot?: () => T\n): T {\n  return useSyncExternalStore(\n    (onStoreChange) => signal.sub(onStoreChange),\n    signal,\n    getServerSnapshot || signal\n  );\n}\n"],
  "mappings": "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",
  "names": ["Pe", "t", "ot", "e", "n", "ut", "r", "A", "a", "i", "u", "o", "p", "w", "ct", "pt", "ee", "W", "Se", "G", "te", "g", "s", "l", "T", "B", "F", "k", "je", "K", "Ae", "qe", "Me", "lt", "ft", "Y", "dt", "Te", "_t", "ln", "yt", "fn", "Ie", "de", "bt", "_e", "ne", "H", "f", "L", "st", "y", "b", "P", "rt", "S", "ce", "C", "pe", "le", "fe", "ye", "dn", "Q", "ht", "mt", "Z", "Le", "Re", "vt", "gt", "wt", "We", "Et", "kt", "m", "v", "De", "xt", "$t", "Ce", "Ne", "x", "Ue", "Pt", "I", "Oe", "Je", "re", "q", "D", "_", "ze", "d", "be", "se", "Ge", "Be", "$", "St", "jt", "X", "ie", "Fe", "At", "ae", "oe", "qt", "Ke", "he", "Rt", "Mt", "Tt", "It", "Lt", "Wt", "Dt", "Ye", "J", "me", "Ct", "He", "Nt", "Qe", "Ze", "Ut", "Ot", "Xe", "Jt", "zt", "c", "ve", "R", "ue", "Gt", "ge", "Bt", "Ve", "Kt", "Ft", "we", "Yt", "Ht", "Qt", "M", "Zt", "_n", "Xt", "yn", "Vt", "en", "bn", "tn", "hn", "nn", "mn", "rn", "vn", "sn", "an", "on", "z", "V", "et", "tt", "Ee", "ke", "nt", "un", "gn", "wn", "En", "cn", "xe", "pn", "h", "$e", "kn", "xn", "j", "createSignal", "initialValue", "options", "signal", "createComputed", "computed", "createSignalsTuple", "debug", "logInfo", "logError", "createLogger", "setDebug", "value", "setBridgeDebug", "$lastRequestId", "$postEvent", "_postEvent", "_launchParams", "launchParams", "version", "configure", "postEvent", "lp", "retrieveLaunchParams", "createPostEvent", "createRequestId", "invokeCustomMethod", "method", "params", "_invokeCustomMethod", "request", "eventOrEvents", "_request", "createIsSupported", "supports", "proxyMessage", "message", "CSSVarsBoundError", "isCSSVarsBoundError", "errorClass", "NotAvailableError", "isNotAvailableError", "InvalidEnvError", "isInvalidEnvError", "FunctionUnavailableError", "isFunctionNotAvailableError", "InvalidArgumentsError", "isInvalidArguments", "cause", "ConcurrentCallError", "isConcurrentCallError", "SetEmojiStatusError", "isSetEmojiStatusError", "error", "AccessDeniedError", "isAccessDeniedError", "FullscreenFailedError", "isFullscreenFailedError", "ShareMessageError", "isShareMessageError", "isSSR", "wrapSafe", "optionsIsSupported", "isMounted", "isMounting", "component", "optionSupports", "functionId", "isSupported", "supportsOption", "option", "tuple", "supportError", "getError", "item", "isSupportedItems", "errors", "supportsOptionError", "args", "supportsMap", "$isSupported", "$isInitialized", "$isMounted", "$isAvailable", "isTMA", "errMessagePrefix", "supportErr", "supportsOptionErr", "createWrapSafe", "overrideIsSupported", "createWrapComplete", "createWrapSupported", "SETUP_METHOD_NAME", "CLICK_EVENT_NAME", "COMPONENT_NAME", "_isVisible", "isVisible", "_isMounted", "wrapComplete", "wrapSupported", "hide", "setVisibility", "mount", "isPageReload", "getStorageValue", "setStorageValue", "onClick", "offClick", "off", "show", "unmount", "E", "defineNonConcurrentFn", "errorMessage", "optionsPromise", "optionsError", "_promise", "promise", "_error", "err", "AbortablePromise", "batch", "defineMountFn", "onMounted", "rest", "data", "_state", "state", "isAvailable", "METHOD_NAME", "requestBiometry", "ignoreCanceled", "isCancelledError", "signalCancel", "REQUEST_AUTH_METHOD", "INFO_RECEIVED_EVENT", "onBiometryInfoReceived", "setState", "eventToState", "throwNotAvailable", "event", "available", "tokenSaved", "deviceId", "accessRequested", "type", "accessGranted", "mountFn", "tMountPromise", "tMountError", "tIsMounted", "abortSignal", "mountPromise", "mountError", "authFn", "tAuthPromise", "tAuthError", "context", "token", "authenticate", "authPromise", "isAuthenticating", "authError", "openSettings", "requestAccessFn", "tRequestAccessPromise", "tRequestAccessError", "requestAccess", "requestAccessPromise", "isRequestingAccess", "requestAccessError", "updateToken", "createWrapMounted", "createWrapBasic", "_isConfirmationEnabled", "isConfirmationEnabled", "wrapMounted", "wrapBasic", "disableConfirmation", "setClosingConfirmation", "enableConfirmation", "store", "getGlobalConfig", "config2", "store2", "getGlobalMessage", "lang", "store3", "getSchemaMessage", "store4", "getSpecificMessage", "reference", "_a", "_stringify", "input", "_b", "_addIssue", "label", "dataset", "other", "expected", "received", "issue", "isSchema", "_getStandardProps", "value2", "_isValidObjectKey", "object2", "key", "_joinExpects", "values", "separator", "list", "ValiError", "issues", "integer", "transform", "operation", "getDefault", "schema", "array", "itemDataset", "pathItem", "date", "instance", "class_", "looseObject", "entries", "valueSchema", "valueDataset", "number", "optional", "wrapped", "default_", "record", "entryKey", "entryValue", "keyDataset", "string", "_subIssues", "datasets", "union", "validDataset", "typedDatasets", "untypedDatasets", "optionDataset", "parse", "pipe", "pipe2", "INVOKE_METHOD_NAME", "deleteItem", "keyOrKeys", "keys", "_getItem", "response", "acc", "getItem", "getKeys", "setItem", "clear", "HAPTIC_METHOD_NAME", "impactOccurred", "style", "notificationOccurred", "selectionChanged", "fromState", "authDate", "canSendAfter", "canSendAfterDate", "authDateValue", "canSendAfterValue", "chat", "chatType", "chatInstance", "hash", "queryId", "_raw", "raw", "receiver", "restore", "retrieveRawInitData", "startParam", "user", "_open", "urlOrSlug", "optionsOrType", "slug", "hostname", "pathname", "match", "tOpenPromise", "tOpenError", "open", "openPromise", "isOpened", "openError", "CHECK_LOCATION_METHOD", "OPEN_SETTINGS_METHOD", "isAccessGranted", "isAccessRequested", "reqLocationFn", "tReqLocationPromise", "tReqLocationError", "requestLocation", "requestLocationPromise", "isRequestingLocation", "requestLocationError", "removeUndefined", "result", "N", "U", "O", "isColorDark", "color", "rgb", "toRGB", "modifier", "idx", "dec", "_isCssVarsBound", "isCssVarsBound", "accentTextColor", "backgroundColor", "buttonColor", "buttonTextColor", "bottomBarBgColor", "destructiveTextColor", "headerBackgroundColor", "hintColor", "isDark", "linkColor", "secondaryBackgroundColor", "sectionBackgroundColor", "sectionHeaderTextColor", "sectionSeparatorColor", "subtitleTextColor", "textColor", "internalState", "hasShineEffect", "isEnabled", "isLoaderVisible", "text", "prev", "setParams", "updates", "setCssVar", "name", "deleteCssVar", "THEME_CHANGED_EVENT", "onThemeChanged", "bindCssVars", "getCSSVarName", "prop", "snakeToKebab", "forEachEntry", "actualize", "rgbBasedOn", "isRGB", "themeBgColor", "themeSecondaryBgColor", "_backgroundColor", "backgroundColorRGB", "_bottomBarColor", "bottomBarColor", "bottomBarColorRGB", "themeBottomBarBgColor", "_headerColor", "headerColor", "headerColorRGB", "_isActive", "isActive", "SET_BG_COLOR_METHOD", "SET_BOTTOM_BAR_COLOR_METHOD", "SET_HEADER_COLOR_METHOD", "VISIBILITY_CHANGED_EVENT", "isSupportedSchema", "onVisibilityChanged", "saveState", "mountThemeParams", "setBackgroundColor", "setBottomBarColor", "setHeaderColor", "addCleanup", "cleanup", "createCbCollector", "bind", "cssVar", "update", "camelToKebab", "close", "returnBack", "ready", "prepareParams", "title", "buttons", "id", "OPEN_METHOD", "tPromise", "tShowError", "buttonId", "showPromise", "isShown", "showError", "CLOSE_METHOD", "CLOSED_EVENT", "TEXT_RECEIVED_EVENT", "onCaptured", "capture", "ManualPromise", "openFn", "position", "_isVerticalEnabled", "isVerticalEnabled", "disableVertical", "setVerticalEnabled", "enableVertical", "force", "FS_CHANGED_EVENT", "SA_CHANGED_EVENT", "CSA_CHANGED_EVENT", "VIEWPORT_CHANGED_EVENT", "initialInsets", "nonNegative", "signalFromState", "height", "stableHeight", "width", "isExpanded", "isStable", "getStateFromStorage", "fromCsaState", "contentSafeAreaInsets", "contentSafeAreaInsetBottom", "contentSafeAreaInsetLeft", "contentSafeAreaInsetRight", "contentSafeAreaInsetTop", "fromSaState", "safeAreaInsets", "safeAreaInsetBottom", "safeAreaInsetLeft", "safeAreaInsetRight", "safeAreaInsetTop", "REQUEST_SA_METHOD_NAME", "requestContentSafeAreaInsets", "requestViewport", "requestSafeAreaInsets", "onViewportChanged", "onFullscreenChanged", "onSafeAreaChanged", "onContentSafeAreaChanged", "insets", "shared", "settings", "setting", "expand", "REQUEST_METHOD_NAME", "isFullscreen", "_changeFullscreenPromise", "changeFullscreenPromise", "_changeFullscreenError", "changeFullscreenError", "createFullscreenFn", "isRequest", "requestFullscreen", "exitFullscreen", "METHOD", "tError", "requestEmojiStatusAccess", "requestEmojiStatusAccessPromise", "isRequestingEmojiStatusAccess", "requestEmojiStatusAccessError", "customEmojiId", "setEmojiStatus", "setEmojiStatusPromise", "isSettingEmojiStatus", "setEmojiStatusError", "wrapOptions", "EVENT_NAME", "onAddToHomeScreenFailed", "listener", "once", "offAddToHomeScreenFailed", "onAddedToHomeScreen", "offAddedToHomeScreen", "addToHomeScreen", "checkHomeScreenStatus", "checkHomeScreenStatusPromise", "isCheckingHomeScreenStatus", "checkHomeScreenStatusError", "openLink", "url", "OPEN_TG_LINK_METHOD", "openTelegramLink", "urlString", "shareURL", "sleep", "duration", "requestPhoneAccess", "requestPhoneAccessPromise", "isRequestingPhoneAccess", "requestPhoneAccessError", "getRequestedContact", "transformQueryUsing", "jsonParse", "res", "sleepTime", "requestContact", "requestContactPromise", "isRequestingContact", "requestContactError", "requestWriteAccess", "requestWriteAccessPromise", "isRequestingWriteAccess", "requestWriteAccessError", "fallback", "textArea", "copyTextToClipboard", "clipboard", "downloadFile", "fileName", "getCurrentTime", "readTextFromClipboard", "reqId", "captureSameReq", "sendData", "size", "shareMessage", "SHARE_STORY_METHOD", "shareStory", "mediaUrl", "SWITCH_INLINE_QUERY_METHOD", "switchInlineQuery", "query", "chatTypes", "safeCall", "init", "acceptCustomStyles", "html", "useSignal", "signal", "getServerSnapshot", "useSyncExternalStore", "onStoreChange"]
}
